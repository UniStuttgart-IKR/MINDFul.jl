var documenterSearchIndex = {"docs":
[{"location":"HTTP/#HTTP-API","page":"HTTP-API","title":"HTTP-API","text":"","category":"section"},{"location":"HTTP/","page":"HTTP-API","title":"HTTP-API","text":"The Swagger UI for the HTTP-API is available here.","category":"page"},{"location":"OxygenInstance/#OxygenInstance-API","page":"OxygenInstance","title":"OxygenInstance API","text":"","category":"section"},{"location":"OxygenInstance/#MINDFul.Server.OxygenInstance.adjustparams-Tuple{Any, Any}","page":"OxygenInstance","title":"MINDFul.Server.OxygenInstance.adjustparams","text":"adjustparams(path, func)\n\nAdjust the order of path and func based on their types. This is used to support the do ... end syntax for  the routing macros.\n\n\n\n\n\n","category":"method"},{"location":"OxygenInstance/#MINDFul.Server.OxygenInstance.clearcronjobs","page":"OxygenInstance","title":"MINDFul.Server.OxygenInstance.clearcronjobs","text":"Clears all cron job defintions\n\n\n\n\n\n","category":"function"},{"location":"OxygenInstance/#MINDFul.Server.OxygenInstance.cleartasks","page":"OxygenInstance","title":"MINDFul.Server.OxygenInstance.cleartasks","text":"cleartasks(ct::ServerContext)\n\nClear any stored repeat task definitions\n\n\n\n\n\n","category":"function"},{"location":"OxygenInstance/#MINDFul.Server.OxygenInstance.dynamicfiles","page":"OxygenInstance","title":"MINDFul.Server.OxygenInstance.dynamicfiles","text":"dynamicfiles(folder::String, mountdir::String; headers::Vector{Pair{String,String}}=[], loadfile::Union{Function,Nothing}=nothing)\n\nMount all files inside the /static folder (or user defined mount point),  but files are re-read on each request. The headers array will get applied to all mounted files\n\n\n\n\n\n","category":"function"},{"location":"OxygenInstance/#MINDFul.Server.OxygenInstance.getexternalurl-Tuple{}","page":"OxygenInstance","title":"MINDFul.Server.OxygenInstance.getexternalurl","text":"getexternalurl()\n\nReturn the external URL of the service\n\n\n\n\n\n","category":"method"},{"location":"OxygenInstance/#MINDFul.Server.OxygenInstance.getschema-Tuple{}","page":"OxygenInstance","title":"MINDFul.Server.OxygenInstance.getschema","text":"getschema()\n\nReturn the current internal schema for this app\n\n\n\n\n\n","category":"method"},{"location":"OxygenInstance/#MINDFul.Server.OxygenInstance.internalrequest","page":"OxygenInstance","title":"MINDFul.Server.OxygenInstance.internalrequest","text":"internalrequest(req::HTTP.Request; middleware::Vector=[], serialize::Bool=true, catch_errors::Bool=true)\n\nDirectly call one of our other endpoints registered with the router, using your own middleware and bypassing any globally defined middleware\n\n\n\n\n\n","category":"function"},{"location":"OxygenInstance/#MINDFul.Server.OxygenInstance.mergeschema","page":"OxygenInstance","title":"MINDFul.Server.OxygenInstance.mergeschema","text":"mergeschema(route::String, customschema::Dict)\n\nMerge the schema of a specific route\n\n\n\n\n\n","category":"function"},{"location":"OxygenInstance/#MINDFul.Server.OxygenInstance.resetstate-Tuple{}","page":"OxygenInstance","title":"MINDFul.Server.OxygenInstance.resetstate","text":"resetstate()\n\nReset all the internal state variables\n\n\n\n\n\n","category":"method"},{"location":"OxygenInstance/#MINDFul.Server.OxygenInstance.router","page":"OxygenInstance","title":"MINDFul.Server.OxygenInstance.router","text":"\n\n\n\n","category":"function"},{"location":"OxygenInstance/#MINDFul.Server.OxygenInstance.serve","page":"OxygenInstance","title":"MINDFul.Server.OxygenInstance.serve","text":"serve(; middleware::Vector=[], handler=stream_handler, host=\"127.0.0.1\", port=8080, async=false, parallel=false, serialize=true, catch_errors=true, docs=true, metrics=true, show_errors=true, show_banner=true, docs_path=\"/docs\", schema_path=\"/schema\", external_url=nothing, revise, kwargs...)\n\nStart the webserver with your own custom request handler\n\n\n\n\n\n","category":"function"},{"location":"OxygenInstance/#MINDFul.Server.OxygenInstance.serveparallel-Tuple{}","page":"OxygenInstance","title":"MINDFul.Server.OxygenInstance.serveparallel","text":"serveparallel(; middleware::Vector=[], handler=stream_handler, host=\"127.0.0.1\", port=8080, serialize=true, async=false, catch_errors=true, docs=true, metrics=true, kwargs...)\n\n\n\n\n\n","category":"method"},{"location":"OxygenInstance/#MINDFul.Server.OxygenInstance.setschema-Tuple{Dict}","page":"OxygenInstance","title":"MINDFul.Server.OxygenInstance.setschema","text":"setschema(customschema::Dict)\n\nOverwrites the entire internal schema\n\n\n\n\n\n","category":"method"},{"location":"OxygenInstance/#MINDFul.Server.OxygenInstance.startcronjobs","page":"OxygenInstance","title":"MINDFul.Server.OxygenInstance.startcronjobs","text":"startcronjobs()\n\nStart all the cron cronjobs within their own async task. Each individual task will loop conintually  and sleep untill the next time it's suppost to \n\n\n\n\n\n","category":"function"},{"location":"OxygenInstance/#MINDFul.Server.OxygenInstance.starttasks","page":"OxygenInstance","title":"MINDFul.Server.OxygenInstance.starttasks","text":"starttasks()\n\nStart all background repeat tasks\n\n\n\n\n\n","category":"function"},{"location":"OxygenInstance/#MINDFul.Server.OxygenInstance.staticfiles","page":"OxygenInstance","title":"MINDFul.Server.OxygenInstance.staticfiles","text":"staticfiles(folder::String, mountdir::String; headers::Vector{Pair{String,String}}=[], loadfile::Union{Function,Nothing}=nothing)\n\nMount all files inside the /static folder (or user defined mount point).  The headers array will get applied to all mounted files\n\n\n\n\n\n","category":"function"},{"location":"OxygenInstance/#MINDFul.Server.OxygenInstance.stopcronjobs","page":"OxygenInstance","title":"MINDFul.Server.OxygenInstance.stopcronjobs","text":"stopcronjobs()\n\nStop each background task by toggling a global reference that all cron jobs reference\n\n\n\n\n\n","category":"function"},{"location":"OxygenInstance/#MINDFul.Server.OxygenInstance.stoptasks","page":"OxygenInstance","title":"MINDFul.Server.OxygenInstance.stoptasks","text":"stoptasks()\n\nStop all background repeat tasks\n\n\n\n\n\n","category":"function"},{"location":"OxygenInstance/#MINDFul.Server.OxygenInstance.terminate","page":"OxygenInstance","title":"MINDFul.Server.OxygenInstance.terminate","text":"terminate(ctx)\n\nstops the webserver immediately\n\n\n\n\n\n","category":"function"},{"location":"OxygenInstance/#MINDFul.Server.OxygenInstance.@cron-Tuple{Any, Any, Any}","page":"OxygenInstance","title":"MINDFul.Server.OxygenInstance.@cron","text":"@cron(expression::String, name::String, func::Function)\n\nThis variation provides way manually \"name\" a registered function. This information  is used by the server on startup to log out all cron jobs.\n\n\n\n\n\n","category":"macro"},{"location":"OxygenInstance/#MINDFul.Server.OxygenInstance.@cron-Tuple{Any, Any}","page":"OxygenInstance","title":"MINDFul.Server.OxygenInstance.@cron","text":"@cron(expression::String, func::Function)\n\nRegisters a function with a cron expression. This will extract either the function name  or the random Id julia assigns to each lambda function. \n\n\n\n\n\n","category":"macro"},{"location":"OxygenInstance/#MINDFul.Server.OxygenInstance.@delete-Tuple{Any, Any}","page":"OxygenInstance","title":"MINDFul.Server.OxygenInstance.@delete","text":"@delete(path::String, func::Function)\n\nUsed to register a function to a specific endpoint to handle DELETE requests\n\n\n\n\n\n","category":"macro"},{"location":"OxygenInstance/#MINDFul.Server.OxygenInstance.@dynamicfiles","page":"OxygenInstance","title":"MINDFul.Server.OxygenInstance.@dynamicfiles","text":"@dynamicfiles(folder::String, mountdir::String, headers::Vector{Pair{String,String}}=[])\n\nMount all files inside the /static folder (or user defined mount point),  but files are re-read on each request\n\n\n\n\n\n","category":"macro"},{"location":"OxygenInstance/#MINDFul.Server.OxygenInstance.@get-Tuple{Any, Any}","page":"OxygenInstance","title":"MINDFul.Server.OxygenInstance.@get","text":"@get(path::String, func::Function)\n\nUsed to register a function to a specific endpoint to handle GET requests  \n\n\n\n\n\n","category":"macro"},{"location":"OxygenInstance/#MINDFul.Server.OxygenInstance.@patch-Tuple{Any, Any}","page":"OxygenInstance","title":"MINDFul.Server.OxygenInstance.@patch","text":"@patch(path::String, func::Function)\n\nUsed to register a function to a specific endpoint to handle PATCH requests\n\n\n\n\n\n","category":"macro"},{"location":"OxygenInstance/#MINDFul.Server.OxygenInstance.@post-Tuple{Any, Any}","page":"OxygenInstance","title":"MINDFul.Server.OxygenInstance.@post","text":"@post(path::String, func::Function)\n\nUsed to register a function to a specific endpoint to handle POST requests\n\n\n\n\n\n","category":"macro"},{"location":"OxygenInstance/#MINDFul.Server.OxygenInstance.@put-Tuple{Any, Any}","page":"OxygenInstance","title":"MINDFul.Server.OxygenInstance.@put","text":"@put(path::String, func::Function)\n\nUsed to register a function to a specific endpoint to handle PUT requests\n\n\n\n\n\n","category":"macro"},{"location":"OxygenInstance/#MINDFul.Server.OxygenInstance.@repeat-Tuple{Any, Any, Any}","page":"OxygenInstance","title":"MINDFul.Server.OxygenInstance.@repeat","text":"@repeat(interval::Real, name::String, func::Function)\n\nThis variation provides way manually \"name\" a registered repeat task. This information  is used by the server on startup to log out all cron jobs.\n\n\n\n\n\n","category":"macro"},{"location":"OxygenInstance/#MINDFul.Server.OxygenInstance.@repeat-Tuple{Any, Any}","page":"OxygenInstance","title":"MINDFul.Server.OxygenInstance.@repeat","text":"@repeat(interval::Real, func::Function)\n\nRegisters a repeat task. This will extract either the function name  or the random Id julia assigns to each lambda function. \n\n\n\n\n\n","category":"macro"},{"location":"OxygenInstance/#MINDFul.Server.OxygenInstance.@route-Tuple{Any, Any, Any}","page":"OxygenInstance","title":"MINDFul.Server.OxygenInstance.@route","text":"@route(methods::Array{String}, path::String, func::Function)\n\nUsed to register a function to a specific endpoint to handle mulitiple request types\n\n\n\n\n\n","category":"macro"},{"location":"OxygenInstance/#MINDFul.Server.OxygenInstance.@staticfiles","page":"OxygenInstance","title":"MINDFul.Server.OxygenInstance.@staticfiles","text":"@staticfiles(folder::String, mountdir::String, headers::Vector{Pair{String,String}}=[])\n\nMount all files inside the /static folder (or user defined mount point)\n\n\n\n\n\n","category":"macro"},{"location":"OxygenInstance/#MINDFul.Server.OxygenInstance.@stream-Tuple{Any, Any}","page":"OxygenInstance","title":"MINDFul.Server.OxygenInstance.@stream","text":"@stream(path::String, func::Function)\n\nUsed to register a function to a specific endpoint to handle Streaming requests\n\n\n\n\n\n","category":"macro"},{"location":"OxygenInstance/#MINDFul.Server.OxygenInstance.@websocket-Tuple{Any, Any}","page":"OxygenInstance","title":"MINDFul.Server.OxygenInstance.@websocket","text":"@websocket(path::String, func::Function)\n\nUsed to register a function to a specific endpoint to handle WebSocket connections\n\n\n\n\n\n","category":"macro"},{"location":"dev/#Notes-for-developes-and-contributors","page":"Developing","title":"Notes for developes and contributors","text":"","category":"section"},{"location":"dev/#Mental-classification-of-functions-per-functionality","page":"Developing","title":"Mental classification of functions per functionality","text":"","category":"section"},{"location":"dev/","page":"Developing","title":"Developing","text":"(must clarify these notes) To expand upon: allocate - deallocate reserve - unreserve function getters get... -> get field new... -> construct something new prioritize -> return a vector of indices choose -> return a specific (scalar) index comp -> compilation","category":"page"},{"location":"dev/#How-to-read-variables","page":"Developing","title":"How to read variables","text":"","category":"section"},{"location":"dev/","page":"Developing","title":"Developing","text":"transmission -> trans\nmodule -> mdl\nmode -> mode\nindex -> idx\nuuid -> id\nibn framework -> ibnf\n","category":"page"},{"location":"dev/#Testing","page":"Developing","title":"Testing","text":"","category":"section"},{"location":"dev/","page":"Developing","title":"Developing","text":"Usefull testing functions are in the TestModule weak dependency. To access them you first need to load Test and JET and then use Base.get_extention.","category":"page"},{"location":"dev/","page":"Developing","title":"Developing","text":"# get the test module from MINDFul\nimport Test, JET\nTestModule = Base.get_extension(MINDFul, :TestModule)\n@test !isnothing(TM)","category":"page"},{"location":"dev/","page":"Developing","title":"Developing","text":"Now, with dot notation (TestModule.) you can access all the following functions. ","category":"page"},{"location":"dev/#Testing-API","page":"Developing","title":"Testing API","text":"","category":"section"},{"location":"dev/#TestModule.JETfilteroutfunctions-Tuple{Any}","page":"Developing","title":"TestModule.JETfilteroutfunctions","text":"JETfilteroutfunctions(f) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"dev/#TestModule.deserializeorcalculatecachedresults-Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView, Int64}","page":"Developing","title":"TestModule.deserializeorcalculatecachedresults","text":"deserializeorcalculatecachedresults(\n    ibnag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView,\n    candidatepathsnum::Int64;\n    serializedcachedresultsdictpath\n)\n\n\nRead and update the cached results in the file serializedcachedresultsdictpath\n\n\n\n\n\n","category":"method"},{"location":"dev/#TestModule.islowlevelintentdagnodeinstalled-Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView, MINDFul.LowLevelIntent}","page":"Developing","title":"TestModule.islowlevelintentdagnodeinstalled","text":"islowlevelintentdagnodeinstalled(\n    ibnag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView,\n    lli::MINDFul.LowLevelIntent\n) -> Union{Nothing, Test.Error, Test.Fail, Test.Pass}\n\n\n\n\n\n\n","category":"method"},{"location":"dev/#TestModule.localnodesaregraphnodeidx-Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView}","page":"Developing","title":"TestModule.localnodesaregraphnodeidx","text":"localnodesaregraphnodeidx(\n    ibnag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView\n)\n\n\n\n\n\n\n","category":"method"},{"location":"dev/#TestModule.nothingisallocated-Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView}","page":"Developing","title":"TestModule.nothingisallocated","text":"nothingisallocated(\n    ibnag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView\n)\n\n\n\n\n\n\n","category":"method"},{"location":"dev/#TestModule.testcompilation-Tuple{MINDFul.IBNFramework, Base.UUID}","page":"Developing","title":"TestModule.testcompilation","text":"testcompilation(\n    ibnf::MINDFul.IBNFramework,\n    idagnodeid::Base.UUID;\n    withremote\n) -> Union{Nothing, Test.Error, Test.Fail, Test.Pass}\n\n\n\n\n\n\n","category":"method"},{"location":"dev/#TestModule.testinstallation-Tuple{MINDFul.IBNFramework, Base.UUID}","page":"Developing","title":"TestModule.testinstallation","text":"testinstallation(\n    ibnf::MINDFul.IBNFramework,\n    idagnodeid::Base.UUID;\n    withremote\n) -> Union{Nothing, Test.Error, Test.Fail, Test.Pass}\n\n\n\n\n\n\n","category":"method"},{"location":"dev/#TestModule.testlocalnodeisindex-Tuple{Any}","page":"Developing","title":"TestModule.testlocalnodeisindex","text":"testlocalnodeisindex(\n    ibnf\n) -> Union{Test.Error, Test.Fail, Test.Pass}\n\n\n\n\n\n\n","category":"method"},{"location":"dev/#TestModule.testoxcfiberallocationconsistency-Tuple{Any}","page":"Developing","title":"TestModule.testoxcfiberallocationconsistency","text":"testoxcfiberallocationconsistency(ibnf)\n\n\nCheck if the IBNFramework fiber allocations are done from both endpoint oxcviews\n\n\n\n\n\n","category":"method"},{"location":"dev/#TestModule.testuncompilation-Tuple{MINDFul.IBNFramework, Base.UUID}","page":"Developing","title":"TestModule.testuncompilation","text":"testuncompilation(\n    ibnf::MINDFul.IBNFramework,\n    idagnodeid::Base.UUID\n) -> Union{Test.Error, Test.Fail, Test.Pass}\n\n\n\n\n\n\n","category":"method"},{"location":"dev/#TestModule.testuninstallation-Tuple{MINDFul.IBNFramework, Base.UUID}","page":"Developing","title":"TestModule.testuninstallation","text":"testuninstallation(\n    ibnf::MINDFul.IBNFramework,\n    idagnodeid::Base.UUID;\n    withremote,\n    shouldempty\n)\n\n\n\n\n\n\n","category":"method"},{"location":"Docker/#How-to-instantiate-MINDFul.jl-Docker-containers","page":"Docker","title":"How to instantiate MINDFul.jl Docker containers","text":"","category":"section"},{"location":"Docker/","page":"Docker","title":"Docker","text":"Each MINDFul.jl instance is responsible of one domain. The Docker image is built once and run as many times as different domains exist in the network.","category":"page"},{"location":"Docker/#Building-the-Docker-image","page":"Docker","title":"Building the Docker image","text":"","category":"section"},{"location":"Docker/","page":"Docker","title":"Docker","text":"docker build --build-arg COPY_MANIFEST=<bool> -t mindful_docker:latest .","category":"page"},{"location":"Docker/","page":"Docker","title":"Docker","text":"This command must be executed at MINDFul.jl directory. COPY_MANIFEST variable allows the user to include the existing Manifest.toml (true), or create it when building the Docker image (false).","category":"page"},{"location":"Docker/#Running-MINDFul.jl-containers","page":"Docker","title":"Running MINDFul.jl containers","text":"","category":"section"},{"location":"Docker/","page":"Docker","title":"Docker","text":"docker run -it -e configpath=\"path/to/<configX.toml>\" --network host mindful_docker:latest","category":"page"},{"location":"Docker/","page":"Docker","title":"Docker","text":"Repeat this instruction for each domain with the corresponding configuration file. The configpath variable expects the absolute or relative path (w.r.t. the MINDFul.jl directory) of the configuration file for each domain in a TOML format. The corresponding RSA keys must be previously included and referenced in the configuration file with the absolute or relative path (w.r.t. the configX.toml directory). Examples of configuration files are available at test/data.","category":"page"},{"location":"roadmap/#ROADMap","page":"ROADMap","title":"ROADMap","text":"","category":"section"},{"location":"roadmap/#Longterm","page":"ROADMap","title":"Longterm","text":"","category":"section"},{"location":"roadmap/","page":"ROADMap","title":"ROADMap","text":"[x] rewrite (faster, more readable, and cleaner)\n[ ] update companion packages\n[ ] experimental bindings with TeraFlowSDN\n[ ] enable distributed operation","category":"page"},{"location":"roadmap/#Shortterm","page":"ROADMap","title":"Shortterm","text":"","category":"section"},{"location":"roadmap/","page":"ROADMap","title":"ROADMap","text":"[ ] make a template for kspffcompile function\n[ ] provide verbose keyword and functionality for kspffcompile function\n[ ] introduce regeneration in kspffcompile function","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Welcome to MINDFul.jl documentation","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"MINDFul.jl is an open source tool for studying IP-optical intent-based networking.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Intents are compiled down to further lower level intets forming an Directed Acyclic Graph (DAG). The leafs of the DAG are called \"low level intents\" and are basically hardware configurations for the devices.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"There are currently 3 devices to consider:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"the node as a whole\nthe router\nthe optical cross connect (OXC)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"For each of those devices a LLI is corresponding","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"MINDFul.jl was rewritten. Better docs soon.","category":"page"},{"location":"API/#Public-getters-interface","page":"API","title":"Public getters interface","text":"","category":"section"},{"location":"API/#MINDFul.getadddropport-Tuple{MINDFul.EndNodeAllocations}","page":"API","title":"MINDFul.getadddropport","text":"getadddropport(\n    ena::MINDFul.EndNodeAllocations\n) -> Union{Nothing, Int64}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getadddropport-Tuple{MINDFul.MutableEndNodeAllocations}","page":"API","title":"MINDFul.getadddropport","text":"getadddropport(\n    ena::MINDFul.MutableEndNodeAllocations\n) -> Union{Nothing, Int64}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getadddropport-Tuple{MINDFul.OXCAddDropBypassSpectrumLLI}","page":"API","title":"MINDFul.getadddropport","text":"getadddropport(\n    oxcswitchentry::MINDFul.OXCAddDropBypassSpectrumLLI\n) -> Int64\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getadddropport-Tuple{MINDFul.TransmissionModuleLLI}","page":"API","title":"MINDFul.getadddropport","text":"getadddropport(\n    tmlli::MINDFul.TransmissionModuleLLI\n) -> Int64\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getadddropportnumber-Tuple{MINDFul.OXCView}","page":"API","title":"MINDFul.getadddropportnumber","text":"getadddropportnumber(oxcview::MINDFul.OXCView) -> Int64\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getborderedges-Tuple{MINDFul.IBNFramework}","page":"API","title":"MINDFul.getborderedges","text":"getborderedges(\n    ibnf::MINDFul.IBNFramework\n) -> Vector{Graphs.SimpleGraphs.SimpleEdge{Int64}}\n\n\nReturn all border edges that contain at least one border node as endpoints\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getborderglobaledges-Tuple{MINDFul.IBNFramework}","page":"API","title":"MINDFul.getborderglobaledges","text":"getborderglobaledges(ibnf::MINDFul.IBNFramework) -> Vector\n\n\nReturn all border edges that contain at least one border node as endpoints as global \n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getbordernodesasglobal-Tuple{MINDFul.IBNFramework}","page":"API","title":"MINDFul.getbordernodesasglobal","text":"getbordernodesasglobal(ibnf::MINDFul.IBNFramework) -> Vector\n\n\nReturn all border nodes of ibnf with globalnode representation\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getbordernodesaslocal-Tuple{MINDFul.IBNFramework}","page":"API","title":"MINDFul.getbordernodesaslocal","text":"getbordernodesaslocal(ibnf::MINDFul.IBNFramework) -> Vector\n\n\nReturn all border nodes of ibnf with localnode representation\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getconstraints-Tuple{MINDFul.ConnectivityIntent}","page":"API","title":"MINDFul.getconstraints","text":"getconstraints(\n    conintent::MINDFul.ConnectivityIntent\n) -> Vector{T} where T<:MINDFul.AbstractIntentConstraint\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getcost-Tuple{Any}","page":"API","title":"MINDFul.getcost","text":"getcost(s) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getcurrentstate-Tuple{Array{Tuple{Dates.DateTime, S}, 1} where S<:Enum{Int32}}","page":"API","title":"MINDFul.getcurrentstate","text":"getcurrentstate(\n    intentlogstate::Array{Tuple{Dates.DateTime, S}, 1} where S<:Enum{Int32}\n) -> Enum{Int32}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getdestinationnode-Tuple{MINDFul.ConnectivityIntent}","page":"API","title":"MINDFul.getdestinationnode","text":"getdestinationnode(\n    conintent::MINDFul.ConnectivityIntent\n) -> MINDFul.GlobalNode\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getdestinationnode-Tuple{MINDFul.LightpathRepresentation}","page":"API","title":"MINDFul.getdestinationnode","text":"getdestinationnode(\n    lpr::MINDFul.LightpathRepresentation\n) -> MINDFul.GlobalNode\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getdestinationnode-Tuple{MINDFul.OpticalTerminateConstraint}","page":"API","title":"MINDFul.getdestinationnode","text":"getdestinationnode(\n    otc::MINDFul.OpticalTerminateConstraint\n) -> MINDFul.GlobalNode\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getdistance-Tuple{Any}","page":"API","title":"MINDFul.getdistance","text":"getdistance(\n    s\n) -> Unitful.Quantity{Float64, 𝐋, Unitful.FreeUnits{(km,), 𝐋, nothing}}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getdistance-Tuple{MINDFul.EdgeView}","page":"API","title":"MINDFul.getdistance","text":"getdistance(\n    s::MINDFul.EdgeView\n) -> Unitful.Quantity{Float64, 𝐋, Unitful.FreeUnits{(km,), 𝐋, nothing}}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getedgeview-Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView, Graphs.SimpleGraphs.SimpleEdge}","page":"API","title":"MINDFul.getedgeview","text":"getedgeview(\n    ibnag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView,\n    ed::Graphs.SimpleGraphs.SimpleEdge\n) -> MINDFul.EdgeView\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getedgeviews-Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView}","page":"API","title":"MINDFul.getedgeviews","text":"getedgeviews(\n    ibnag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView\n) -> Vector\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getfiberspectrumavailabilities-Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView, Graphs.SimpleGraphs.SimpleEdge{Int64}}","page":"API","title":"MINDFul.getfiberspectrumavailabilities","text":"getfiberspectrumavailabilities(\n    ibnag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView,\n    edge::Graphs.SimpleGraphs.SimpleEdge{Int64};\n    checkfirst\n) -> Union{Nothing, Vector{Bool}}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getfiberspectrumavailabilities-Tuple{MINDFul.IBNFramework, Graphs.SimpleGraphs.SimpleEdge{Int64}}","page":"API","title":"MINDFul.getfiberspectrumavailabilities","text":"getfiberspectrumavailabilities(\n    ibnf::MINDFul.IBNFramework,\n    edge::Graphs.SimpleGraphs.SimpleEdge{Int64};\n    checkfirst,\n    verbose\n) -> Any\n\n\nGet the spectrum availability slots vector for edge\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getglobalnode-Tuple{Any}","page":"API","title":"MINDFul.getglobalnode","text":"getglobalnode(s) -> MINDFul.GlobalNode\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getglobalnode-Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView, Int64}","page":"API","title":"MINDFul.getglobalnode","text":"getglobalnode(\n    ibnag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView,\n    localnode::Int64\n) -> MINDFul.GlobalNode\n\n\nReturn the global representation given the local representation. Return nothing if not found\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getglobalnode-Tuple{MINDFul.SplitGlobalNode}","page":"API","title":"MINDFul.getglobalnode","text":"getglobalnode(\n    splitglobalnode::MINDFul.SplitGlobalNode\n) -> MINDFul.GlobalNode\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getibnag-Tuple{Any}","page":"API","title":"MINDFul.getibnag","text":"getibnag(s) -> Any\n\n\nGet the IBNAttributeGraph\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getibnfhandler-Tuple{MINDFul.IBNFramework, Base.UUID}","page":"API","title":"MINDFul.getibnfhandler","text":"getibnfhandler(\n    s::MINDFul.IBNFramework,\n    uuid::Base.UUID\n) -> MINDFul.AbstractIBNFHandler\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getibnfhandler-Tuple{MINDFul.IBNFramework}","page":"API","title":"MINDFul.getibnfhandler","text":"getibnfhandler(\n    s::MINDFul.IBNFramework\n) -> MINDFul.IBNFramework\n\n\nGet the handler of the given IBNFramework.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getibnfhandlers-Tuple{MINDFul.IBNFramework}","page":"API","title":"MINDFul.getibnfhandlers","text":"getibnfhandlers(\n    s::MINDFul.IBNFramework\n) -> Vector{H} where H<:MINDFul.AbstractIBNFHandler\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getibnfid-Tuple{Any}","page":"API","title":"MINDFul.getibnfid","text":"getibnfid(s) -> Base.UUID\n\n\nGet the id of the IBNFramework\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getibnfid-Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView}","page":"API","title":"MINDFul.getibnfid","text":"getibnfid(\n    ibnag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView\n) -> Base.UUID\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getibnfid-Tuple{MINDFul.RemoteIntent}","page":"API","title":"MINDFul.getibnfid","text":"getibnfid(ri::MINDFul.RemoteIntent) -> Base.UUID\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getidag-Tuple{MINDFul.IBNFramework}","page":"API","title":"MINDFul.getidag","text":"getidag(\n    s::MINDFul.IBNFramework\n) -> AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo}\n\n\nGet the IntentDAG\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getidagcounter-Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo}}","page":"API","title":"MINDFul.getidagcounter","text":"getidagcounter(\n    intentdag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo}\n) -> Int64\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getidagcounter-Tuple{MINDFul.IntentDAGInfo}","page":"API","title":"MINDFul.getidagcounter","text":"getidagcounter(\n    intentdaginfo::MINDFul.IntentDAGInfo\n) -> Int64\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getidagnodeid-Tuple{MINDFul.IntentDAGNode}","page":"API","title":"MINDFul.getidagnodeid","text":"getidagnodeid(idagnode::MINDFul.IntentDAGNode) -> Base.UUID\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getidagnodeid-Tuple{MINDFul.RemoteIntent}","page":"API","title":"MINDFul.getidagnodeid","text":"getidagnodeid(ri::MINDFul.RemoteIntent) -> Base.UUID\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getidagnodestate-Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo}, Base.UUID}","page":"API","title":"MINDFul.getidagnodestate","text":"getidagnodestate(\n    intentdag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo},\n    dagnodeid::Base.UUID\n) -> MINDFul.IntentState.T\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getidagnodestate-Tuple{MINDFul.IntentDAGNode}","page":"API","title":"MINDFul.getidagnodestate","text":"getidagnodestate(\n    idagnode::MINDFul.IntentDAGNode\n) -> MINDFul.IntentState.T\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getinneighbors-Tuple{MINDFul.NodeProperties}","page":"API","title":"MINDFul.getinneighbors","text":"getinneighbors(np::MINDFul.NodeProperties) -> Vector{Int64}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getintent-Tuple{MINDFul.IntentDAGNode}","page":"API","title":"MINDFul.getintent","text":"getintent(\n    idagnode::MINDFul.IntentDAGNode\n) -> MINDFul.AbstractIntent\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getintent-Tuple{MINDFul.RemoteIntent}","page":"API","title":"MINDFul.getintent","text":"getintent(\n    ri::MINDFul.RemoteIntent\n) -> MINDFul.AbstractIntent\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getintranodeviews-Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView}","page":"API","title":"MINDFul.getintranodeviews","text":"getintranodeviews(\n    ibnag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView\n) -> Vector{T} where T<:MINDFul.NodeView\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getisinitiator-Tuple{MINDFul.RemoteIntent}","page":"API","title":"MINDFul.getisinitiator","text":"getisinitiator(ri::MINDFul.RemoteIntent) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getlatitude-Tuple{MINDFul.NodeProperties}","page":"API","title":"MINDFul.getlatitude","text":"getlatitude(np::MINDFul.NodeProperties) -> Float64\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getlinkspectrumavailabilities-Tuple{MINDFul.OXCView}","page":"API","title":"MINDFul.getlinkspectrumavailabilities","text":"getlinkspectrumavailabilities(\n    oxcview::MINDFul.OXCView\n) -> Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, Vector{Bool}}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getlocalnode-Tuple{Any}","page":"API","title":"MINDFul.getlocalnode","text":"getlocalnode(s) -> Int64\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getlocalnode-Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView, MINDFul.GlobalNode}","page":"API","title":"MINDFul.getlocalnode","text":"getlocalnode(\n    ibnag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView,\n    globalnode::MINDFul.GlobalNode\n) -> Any\n\n\nReturn the localnode representation given the global representation. Return nothing if not found\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getlocalnode-Tuple{MINDFul.EndNodeAllocations}","page":"API","title":"MINDFul.getlocalnode","text":"getlocalnode(ena::MINDFul.EndNodeAllocations) -> Int64\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getlocalnode-Tuple{MINDFul.MutableEndNodeAllocations}","page":"API","title":"MINDFul.getlocalnode","text":"getlocalnode(\n    ena::MINDFul.MutableEndNodeAllocations\n) -> Int64\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getlocalnode_input-Tuple{MINDFul.EndNodeAllocations}","page":"API","title":"MINDFul.getlocalnode_input","text":"getlocalnode_input(\n    ena::MINDFul.EndNodeAllocations\n) -> Union{Nothing, Int64}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getlocalnode_input-Tuple{MINDFul.MutableEndNodeAllocations}","page":"API","title":"MINDFul.getlocalnode_input","text":"getlocalnode_input(\n    ena::MINDFul.MutableEndNodeAllocations\n) -> Union{Nothing, Int64}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getlocalnode_input-Tuple{MINDFul.OXCAddDropBypassSpectrumLLI}","page":"API","title":"MINDFul.getlocalnode_input","text":"getlocalnode_input(\n    oxcswitchreservationentry::MINDFul.OXCAddDropBypassSpectrumLLI\n) -> Int64\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getlocalnode_output-Tuple{MINDFul.MutableEndNodeAllocations}","page":"API","title":"MINDFul.getlocalnode_output","text":"getlocalnode_output(ena::MINDFul.MutableEndNodeAllocations)\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getlocalnode_output-Tuple{MINDFul.OXCAddDropBypassSpectrumLLI}","page":"API","title":"MINDFul.getlocalnode_output","text":"getlocalnode_output(\n    oxcswitchentry::MINDFul.OXCAddDropBypassSpectrumLLI\n) -> Int64\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getlogstate-Tuple{MINDFul.IntentDAGNode}","page":"API","title":"MINDFul.getlogstate","text":"getlogstate(\n    idagnode::MINDFul.IntentDAGNode\n) -> Vector{Tuple{Dates.DateTime, MINDFul.IntentState.T}}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getlongitude-Tuple{MINDFul.NodeProperties}","page":"API","title":"MINDFul.getlongitude","text":"getlongitude(np::MINDFul.NodeProperties) -> Float64\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getnodeproperties-Tuple{MINDFul.NodeView}","page":"API","title":"MINDFul.getnodeproperties","text":"getnodeproperties(\n    s::MINDFul.NodeView\n) -> MINDFul.NodeProperties\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getnodeview-Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView, Int64}","page":"API","title":"MINDFul.getnodeview","text":"getnodeview(\n    ibnag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView,\n    node::Int64\n) -> MINDFul.NodeView\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getnodeview-Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView, MINDFul.GlobalNode}","page":"API","title":"MINDFul.getnodeview","text":"getnodeview(\n    ibnag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView,\n    node::MINDFul.GlobalNode\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getnodeview-Tuple{MINDFul.IBNFramework, Int64}","page":"API","title":"MINDFul.getnodeview","text":"getnodeview(\n    ibnf::MINDFul.IBNFramework,\n    node::Int64\n) -> MINDFul.NodeView\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getnodeviews-Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView}","page":"API","title":"MINDFul.getnodeviews","text":"getnodeviews(\n    ibnag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView\n) -> Vector{T} where T<:MINDFul.NodeView\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getopticalinitiateconstraint-Tuple{MINDFul.IBNFramework, Base.UUID}","page":"API","title":"MINDFul.getopticalinitiateconstraint","text":"getopticalinitiateconstraint(\n    ibnf::MINDFul.IBNFramework,\n    idagnodeid::Base.UUID\n) -> Union{Nothing, MINDFul.OpticalInitiateConstraint}\n\n\nGet the OpticalInitiateConstraint for the current intent DAG. If the compilation is not optically terminated return nothing.\n\nTo me this has all the logic needed to be type stable but the compiler fails.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getopticalreach-Tuple{MINDFul.TransmissionMode}","page":"API","title":"MINDFul.getopticalreach","text":"getopticalreach(\n    tm::MINDFul.TransmissionMode\n) -> Unitful.Quantity{Float64, 𝐋, Unitful.FreeUnits{(km,), 𝐋, nothing}}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getoutneighbors-Tuple{MINDFul.NodeProperties}","page":"API","title":"MINDFul.getoutneighbors","text":"getoutneighbors(np::MINDFul.NodeProperties) -> Vector{Int64}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getoxcadddropportindex-Tuple{MINDFul.OXCAddDropBypassSpectrumLLI}","page":"API","title":"MINDFul.getoxcadddropportindex","text":"getoxcadddropportindex(\n    s::MINDFul.OXCAddDropBypassSpectrumLLI\n) -> Int64\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getoxcview-Tuple{MINDFul.NodeView}","page":"API","title":"MINDFul.getoxcview","text":"getoxcview(\n    s::MINDFul.NodeView\n) -> Union{Nothing, MINDFul.OXCView}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getpathspectrumavailabilities-Tuple{MINDFul.IBNFramework, Vector{Int64}}","page":"API","title":"MINDFul.getpathspectrumavailabilities","text":"getpathspectrumavailabilities(\n    ibnf::MINDFul.IBNFramework,\n    localnodespath::Vector{Int64};\n    checkfirst\n) -> Any\n\n\nGet spectrum availabilities along a path of nodes as a BitVector\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getportnumber-Tuple{Any}","page":"API","title":"MINDFul.getportnumber","text":"getportnumber(s) -> Int64\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getportnumber-Tuple{MINDFul.RouterView}","page":"API","title":"MINDFul.getportnumber","text":"getportnumber(s::MINDFul.RouterView) -> Int64\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getproperties-Tuple{MINDFul.EdgeView}","page":"API","title":"MINDFul.getproperties","text":"getproperties(s::MINDFul.EdgeView) -> MINDFul.EdgeProperties\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getproperties-Tuple{MINDFul.NodeView}","page":"API","title":"MINDFul.getproperties","text":"getproperties(s::MINDFul.NodeView) -> MINDFul.NodeProperties\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getrate-Tuple{MINDFul.ConnectivityIntent}","page":"API","title":"MINDFul.getrate","text":"getrate(\n    conintent::MINDFul.ConnectivityIntent\n) -> Unitful.Quantity{Float64, Data 𝐓^-1, Unitful.FreeUnits{(Gbps,), Data 𝐓^-1, nothing}}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getrate-Tuple{MINDFul.RouterPort}","page":"API","title":"MINDFul.getrate","text":"getrate(\n    s::MINDFul.RouterPort\n) -> Unitful.Quantity{Float64, Data 𝐓^-1, Unitful.FreeUnits{(Gbps,), Data 𝐓^-1, nothing}}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getrate-Tuple{MINDFul.TransmissionMode}","page":"API","title":"MINDFul.getrate","text":"getrate(\n    tm::MINDFul.TransmissionMode\n) -> Unitful.Quantity{Float64, Data 𝐓^-1, Unitful.FreeUnits{(Gbps,), Data 𝐓^-1, nothing}}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getrate-Tuple{MINDFul.TransmissionModuleCompatibility}","page":"API","title":"MINDFul.getrate","text":"getrate(\n    tmc::MINDFul.TransmissionModuleCompatibility\n) -> Unitful.Quantity{Float64, Data 𝐓^-1, Unitful.FreeUnits{(Gbps,), Data 𝐓^-1, nothing}}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getreservations-Tuple{MINDFul.NodeView}","page":"API","title":"MINDFul.getreservations","text":"getreservations(\n    nodeview::MINDFul.NodeView\n) -> Union{Nothing, Dict{Base.UUID, MINDFul.TransmissionModuleLLI}}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getreservations-Tuple{MINDFul.OXCView}","page":"API","title":"MINDFul.getreservations","text":"getreservations(\n    oxcview::MINDFul.OXCView\n) -> Dict{Base.UUID, MINDFul.OXCAddDropBypassSpectrumLLI}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getreservations-Tuple{MINDFul.RouterView}","page":"API","title":"MINDFul.getreservations","text":"getreservations(\n    routerview::MINDFul.RouterView\n) -> Dict{Base.UUID, MINDFul.RouterPortLLI}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getreservedtransmissionmode-Tuple{MINDFul.IBNFramework, MINDFul.IntentDAGNode{MINDFul.TransmissionModuleLLI}}","page":"API","title":"MINDFul.getreservedtransmissionmode","text":"getreservedtransmissionmode(\n    ibnf::MINDFul.IBNFramework,\n    idagnode::MINDFul.IntentDAGNode{MINDFul.TransmissionModuleLLI};\n    verbose\n) -> Union{MINDFul.TransmissionMode, Symbol}\n\n\nGet the reserved transmission mode\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getrouterportindex-Tuple{MINDFul.EndNodeAllocations}","page":"API","title":"MINDFul.getrouterportindex","text":"getrouterportindex(\n    ena::MINDFul.EndNodeAllocations\n) -> Union{Nothing, Int64}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getrouterportindex-Tuple{MINDFul.MutableEndNodeAllocations}","page":"API","title":"MINDFul.getrouterportindex","text":"getrouterportindex(\n    ena::MINDFul.MutableEndNodeAllocations\n) -> Union{Nothing, Int64}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getrouterportindex-Tuple{MINDFul.RouterPortLLI}","page":"API","title":"MINDFul.getrouterportindex","text":"getrouterportindex(s::MINDFul.RouterPortLLI) -> Int64\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getrouterportindex-Tuple{MINDFul.TransmissionModuleLLI}","page":"API","title":"MINDFul.getrouterportindex","text":"getrouterportindex(\n    s::MINDFul.TransmissionModuleLLI\n) -> Int64\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getrouterview-Tuple{MINDFul.NodeView}","page":"API","title":"MINDFul.getrouterview","text":"getrouterview(\n    s::MINDFul.NodeView\n) -> Union{Nothing, MINDFul.RouterView}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getsdncontroller-Tuple{Any}","page":"API","title":"MINDFul.getsdncontroller","text":"getsdncontroller(s) -> Any\n\n\nGet the sdn controller subtype of AbstractSDNController\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getsourcenode-Tuple{MINDFul.ConnectivityIntent}","page":"API","title":"MINDFul.getsourcenode","text":"getsourcenode(\n    conintent::MINDFul.ConnectivityIntent\n) -> MINDFul.GlobalNode\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getspectrumavailability-Tuple{Any}","page":"API","title":"MINDFul.getspectrumavailability","text":"getspectrumavailability(s) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getspectrumslots-Tuple{Any}","page":"API","title":"MINDFul.getspectrumslots","text":"getspectrumslots(s) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getspectrumslotsneeded-Tuple{MINDFul.TransmissionMode}","page":"API","title":"MINDFul.getspectrumslotsneeded","text":"getspectrumslotsneeded(\n    tm::MINDFul.TransmissionMode\n) -> Int64\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getspectrumslotsneeded-Tuple{MINDFul.TransmissionModuleCompatibility}","page":"API","title":"MINDFul.getspectrumslotsneeded","text":"getspectrumslotsneeded(\n    tmc::MINDFul.TransmissionModuleCompatibility\n) -> Int64\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getspectrumslotsrange-Tuple{MINDFul.LightpathIntent}","page":"API","title":"MINDFul.getspectrumslotsrange","text":"getspectrumslotsrange(\n    lpintent::MINDFul.LightpathIntent\n) -> UnitRange{Int64}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getspectrumslotsrange-Tuple{MINDFul.OXCAddDropBypassSpectrumLLI}","page":"API","title":"MINDFul.getspectrumslotsrange","text":"getspectrumslotsrange(\n    oxcswitchentry::MINDFul.OXCAddDropBypassSpectrumLLI\n) -> UnitRange{Int64}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.gettransmissionmode-Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView, MINDFul.TransmissionModuleLLI}","page":"API","title":"MINDFul.gettransmissionmode","text":"gettransmissionmode(\n    ibnag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView,\n    oxclli::MINDFul.TransmissionModuleLLI\n) -> MINDFul.TransmissionMode\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.gettransmissionmode-Tuple{MINDFul.IBNFramework, MINDFul.IntentDAGNode{MINDFul.TransmissionModuleLLI}}","page":"API","title":"MINDFul.gettransmissionmode","text":"gettransmissionmode(\n    ibnf::MINDFul.IBNFramework,\n    idagnode::MINDFul.IntentDAGNode{MINDFul.TransmissionModuleLLI}\n) -> MINDFul.TransmissionMode\n\n\nGet the transmission mode\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.gettransmissionmode-Tuple{MINDFul.IBNFramework, MINDFul.TransmissionModuleLLI}","page":"API","title":"MINDFul.gettransmissionmode","text":"gettransmissionmode(\n    ibnf::MINDFul.IBNFramework,\n    intent::MINDFul.TransmissionModuleLLI\n) -> MINDFul.TransmissionMode\n\n\nGet the transmission mode\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.gettransmissionmode-Tuple{MINDFul.TransmissionModuleView, Int64}","page":"API","title":"MINDFul.gettransmissionmode","text":"gettransmissionmode(\n    s::MINDFul.TransmissionModuleView,\n    transmissionmodeidx::Int64\n) -> MINDFul.TransmissionMode\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.gettransmissionmodes-Tuple{MINDFul.TransmissionModuleView}","page":"API","title":"MINDFul.gettransmissionmodes","text":"gettransmissionmodes(\n    s::MINDFul.TransmissionModuleView\n) -> Vector{MINDFul.TransmissionMode}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.gettransmissionmodesindex-Tuple{MINDFul.EndNodeAllocations}","page":"API","title":"MINDFul.gettransmissionmodesindex","text":"gettransmissionmodesindex(\n    ena::MINDFul.EndNodeAllocations\n) -> Union{Nothing, Int64}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.gettransmissionmodesindex-Tuple{MINDFul.MutableEndNodeAllocations}","page":"API","title":"MINDFul.gettransmissionmodesindex","text":"gettransmissionmodesindex(\n    ena::MINDFul.MutableEndNodeAllocations\n) -> Union{Nothing, Int64}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.gettransmissionmodesindex-Tuple{MINDFul.TransmissionModuleLLI}","page":"API","title":"MINDFul.gettransmissionmodesindex","text":"gettransmissionmodesindex(\n    s::MINDFul.TransmissionModuleLLI\n) -> Int64\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.gettransmissionmodule-Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView, MINDFul.TransmissionModuleLLI}","page":"API","title":"MINDFul.gettransmissionmodule","text":"gettransmissionmodule(\n    ibnag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView,\n    oxclli::MINDFul.TransmissionModuleLLI\n) -> MINDFul.TransmissionModuleView\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.gettransmissionmodule-Tuple{MINDFul.IBNFramework, MINDFul.TransmissionModuleLLI}","page":"API","title":"MINDFul.gettransmissionmodule","text":"gettransmissionmodule(\n    ibnf::MINDFul.IBNFramework,\n    intent::MINDFul.TransmissionModuleLLI\n) -> MINDFul.TransmissionModuleView\n\n\nGet the transmission mode\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.gettransmissionmodulecompat-Tuple{MINDFul.OpticalInitiateConstraint}","page":"API","title":"MINDFul.gettransmissionmodulecompat","text":"gettransmissionmodulecompat(\n    oic::MINDFul.OpticalInitiateConstraint\n) -> MINDFul.TransmissionModuleCompatibility\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.gettransmissionmodulereservations-Tuple{MINDFul.NodeView}","page":"API","title":"MINDFul.gettransmissionmodulereservations","text":"gettransmissionmodulereservations(\n    s::MINDFul.NodeView\n) -> Dict{Base.UUID, MINDFul.TransmissionModuleLLI}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.gettransmissionmoduleviewpool-Tuple{MINDFul.NodeView}","page":"API","title":"MINDFul.gettransmissionmoduleviewpool","text":"gettransmissionmoduleviewpool(\n    s::MINDFul.NodeView\n) -> Union{Nothing, Vector{T}} where T<:MINDFul.TransmissionModuleView\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.gettransmissionmoduleviewpoolindex-Tuple{MINDFul.EndNodeAllocations}","page":"API","title":"MINDFul.gettransmissionmoduleviewpoolindex","text":"gettransmissionmoduleviewpoolindex(\n    ena::MINDFul.EndNodeAllocations\n) -> Union{Nothing, Int64}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.gettransmissionmoduleviewpoolindex-Tuple{MINDFul.MutableEndNodeAllocations}","page":"API","title":"MINDFul.gettransmissionmoduleviewpoolindex","text":"gettransmissionmoduleviewpoolindex(\n    ena::MINDFul.MutableEndNodeAllocations\n) -> Union{Nothing, Int64}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.gettransmissionmoduleviewpoolindex-Tuple{MINDFul.TransmissionModuleLLI}","page":"API","title":"MINDFul.gettransmissionmoduleviewpoolindex","text":"gettransmissionmoduleviewpoolindex(\n    s::MINDFul.TransmissionModuleLLI\n) -> Int64\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getunderlyingequipment-Tuple{MINDFul.TransmissionModuleView}","page":"API","title":"MINDFul.getunderlyingequipment","text":"getunderlyingequipment(\n    s::MINDFul.TransmissionModuleView\n) -> MINDFul.AbstractTransmissionModule\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getweights-Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView}","page":"API","title":"MINDFul.getweights","text":"getweights(\n    ibnag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView\n) -> Matrix\n\n\n\n\n\n\n","category":"method"},{"location":"API/#Other-public-interface","page":"API","title":"Other public interface","text":"","category":"section"},{"location":"API/#MINDFul.addintent!-Tuple{MINDFul.IBNFramework, MINDFul.AbstractIntent, MINDFul.IntentIssuer}","page":"API","title":"MINDFul.addintent!","text":"addintent!(\n    ibnf::MINDFul.IBNFramework,\n    intent::MINDFul.AbstractIntent,\n    intentissuer::MINDFul.IntentIssuer;\n    offsettime\n) -> MINDFul.ReturnUUIDTime\n\n\nkk Add a new user intent to the IBN framework and return the id.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.compileintent!-Tuple{MINDFul.IBNFramework, Base.UUID}","page":"API","title":"MINDFul.compileintent!","text":"compileintent!(\n    ibnf::MINDFul.IBNFramework,\n    idagnodeid::Base.UUID;\n    verbose,\n    offsettime\n) -> MINDFul.ReturnCodeTime\n\n\nTHIS SHOULD BE THE ENTRY FUNCTION. DO NOT USE DIRECTLY THE idagnode ONES.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.compileintent!-Tuple{MINDFul.IBNFramework, MINDFul.IntentDAGNode{<:MINDFul.LightpathIntent}}","page":"API","title":"MINDFul.compileintent!","text":"compileintent!(\n    ibnf::MINDFul.IBNFramework,\n    idagnode::MINDFul.IntentDAGNode{<:MINDFul.LightpathIntent};\n    verbose,\n    offsettime\n) -> Symbol\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.compileintent!-Tuple{MINDFul.IBNFramework, MINDFul.IntentDAGNode{<:MINDFul.ProtectedLightpathIntent}}","page":"API","title":"MINDFul.compileintent!","text":"compileintent!(\n    ibnf::MINDFul.IBNFramework,\n    idagnode::MINDFul.IntentDAGNode{<:MINDFul.ProtectedLightpathIntent};\n    verbose,\n    offsettime\n) -> Symbol\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.compileintent!-Tuple{MINDFul.IBNFramework, MINDFul.IntentDAGNode{<:MINDFul.RemoteIntent}}","page":"API","title":"MINDFul.compileintent!","text":"compileintent!(\n    ibnf::MINDFul.IBNFramework,\n    idagnode::MINDFul.IntentDAGNode{<:MINDFul.RemoteIntent};\n    verbose,\n    offsettime\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.compileintent!-Tuple{MINDFul.IBNFramework{A, B, C, D, MINDFul.BestEmpiricalAvailabilityCompilation} where {A, B, C, D}, MINDFul.IntentDAGNode{<:MINDFul.ConnectivityIntent}}","page":"API","title":"MINDFul.compileintent!","text":"compileintent!(\n    ibnf::MINDFul.IBNFramework{A, B, C, D, MINDFul.BestEmpiricalAvailabilityCompilation} where {A, B, C, D},\n    idagnode::MINDFul.IntentDAGNode{<:MINDFul.ConnectivityIntent};\n    verbose,\n    offsettime\n) -> Symbol\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.compileintent!-Tuple{MINDFul.IBNFramework{A, B, C, D, R} where {A, B, C, D, R<:MINDFul.KShorestPathFirstFitCompilation}, MINDFul.IntentDAGNode{<:MINDFul.ConnectivityIntent}}","page":"API","title":"MINDFul.compileintent!","text":"compileintent!(\n    ibnf::MINDFul.IBNFramework{A, B, C, D, R} where {A, B, C, D, R<:MINDFul.KShorestPathFirstFitCompilation},\n    idagnode::MINDFul.IntentDAGNode{<:MINDFul.ConnectivityIntent};\n    verbose,\n    offsettime\n) -> Symbol\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.findindexglobalnode-Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView, MINDFul.GlobalNode}","page":"API","title":"MINDFul.findindexglobalnode","text":"findindexglobalnode(\n    ibnag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView,\n    globalnode::MINDFul.GlobalNode\n) -> Union{Nothing, Int64}\n\n\nConvenience function that returns the findfirst for the global node \n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.installintent!-Tuple{MINDFul.IBNFramework, Base.UUID}","page":"API","title":"MINDFul.installintent!","text":"installintent!(\n    ibnf::MINDFul.IBNFramework,\n    idagnodeid::Base.UUID;\n    verbose,\n    offsettime\n) -> MINDFul.ReturnCodeTime\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.isbordernode-Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView, Int64}","page":"API","title":"MINDFul.isbordernode","text":"isbordernode(\n    ibnag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView,\n    localnode::Int64\n) -> Bool\n\n\nReturn boolean if localnode is in ibnf as a border node\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.isbordernode-Tuple{MINDFul.IBNFramework, Int64}","page":"API","title":"MINDFul.isbordernode","text":"isbordernode(\n    ibnf::MINDFul.IBNFramework,\n    localnode::Int64\n) -> Any\n\n\nReturn boolean if localnode is in ibnf as a border node\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.isbordernode-Tuple{MINDFul.IBNFramework, MINDFul.GlobalNode}","page":"API","title":"MINDFul.isbordernode","text":"isbordernode(\n    ibnf::MINDFul.IBNFramework,\n    globalnode::MINDFul.GlobalNode\n) -> Any\n\n\nReturn boolean if globalnode is in ibnf as a border node\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.isinternalnode-Tuple{MINDFul.IBNFramework, MINDFul.GlobalNode}","page":"API","title":"MINDFul.isinternalnode","text":"isinternalnode(\n    ibnf::MINDFul.IBNFramework,\n    globalnode::MINDFul.GlobalNode\n) -> Bool\n\n\nReturn boolean if globalnode belongs to ibnf\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.remoteintent!-Tuple{MINDFul.IBNFramework, MINDFul.IntentDAGNode, Base.UUID}","page":"API","title":"MINDFul.remoteintent!","text":"remoteintent!(\n    ibnf::MINDFul.IBNFramework,\n    idagnode::MINDFul.IntentDAGNode,\n    remoteibnfid::Base.UUID;\n    offsettime\n) -> MINDFul.IntentDAGNode{I, MINDFul.MachineGenerated} where I<:MINDFul.RemoteIntent\n\n\nAdd a RemoteIntent as a child intent and delegate it to the ibn with id remoteibndif\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.removeintent!-Tuple{MINDFul.IBNFramework, Base.UUID}","page":"API","title":"MINDFul.removeintent!","text":"removeintent!(\n    ibnf::MINDFul.IBNFramework,\n    idagnodeid::Base.UUID;\n    verbose,\n    offsettime\n) -> MINDFul.ReturnCodeTime\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.uncompileintent!-Tuple{MINDFul.IBNFramework, Base.UUID}","page":"API","title":"MINDFul.uncompileintent!","text":"uncompileintent!(\n    ibnf::MINDFul.IBNFramework,\n    idagnodeid::Base.UUID;\n    verbose,\n    offsettime\n) -> MINDFul.ReturnCodeTime\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.uninstallintent!-Tuple{MINDFul.IBNFramework, Base.UUID}","page":"API","title":"MINDFul.uninstallintent!","text":"uninstallintent!(\n    ibnf::MINDFul.IBNFramework,\n    idagnodeid::Base.UUID;\n    verbose,\n    offsettime\n) -> MINDFul.ReturnCodeTime\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.IntentState","page":"API","title":"MINDFul.IntentState","text":"All possible default intent states. Another intent state schema could be defined.\n\n\n\n\n\n","category":"module"},{"location":"API/#Public-return-codes","page":"API","title":"Public return codes","text":"","category":"section"},{"location":"API/#MINDFul.ReturnCodes","page":"API","title":"MINDFul.ReturnCodes","text":"The return codes defined for functions to give back explaining the situation.    Mostly used for the compilation of an intent.    All the const variables have a Symbol value that is the same as the variable name but only the first letter capitalized.\n\n\n\n\n\n","category":"module"},{"location":"API/#MINDFul.ReturnCodes.FAIL","page":"API","title":"MINDFul.ReturnCodes.FAIL","text":"Signifies generic failure\n\n\n\n\n\n","category":"constant"},{"location":"API/#MINDFul.ReturnCodes.FAIL_CANDIDATEPATHS","page":"API","title":"MINDFul.ReturnCodes.FAIL_CANDIDATEPATHS","text":"Not appropriate candidate paths\n\n\n\n\n\n","category":"constant"},{"location":"API/#MINDFul.ReturnCodes.FAIL_DSTOXCADDDROPPORT","page":"API","title":"MINDFul.ReturnCodes.FAIL_DSTOXCADDDROPPORT","text":"Destination OXC Add/Drop port not found\n\n\n\n\n\n","category":"constant"},{"location":"API/#MINDFul.ReturnCodes.FAIL_DSTROUTERPORT","page":"API","title":"MINDFul.ReturnCodes.FAIL_DSTROUTERPORT","text":"No available router ports were found in destination node\n\n\n\n\n\n","category":"constant"},{"location":"API/#MINDFul.ReturnCodes.FAIL_DSTTRANSMDL","page":"API","title":"MINDFul.ReturnCodes.FAIL_DSTTRANSMDL","text":"Destination transmission module not found\n\n\n\n\n\n","category":"constant"},{"location":"API/#MINDFul.ReturnCodes.FAIL_GROOMEDREMOTEINTENTSTATE","page":"API","title":"MINDFul.ReturnCodes.FAIL_GROOMEDREMOTEINTENTSTATE","text":"Used a remote intent to groom and that remote intent state was not installed or compiled\n\n\n\n\n\n","category":"constant"},{"location":"API/#MINDFul.ReturnCodes.FAIL_OPTICALREACH","page":"API","title":"MINDFul.ReturnCodes.FAIL_OPTICALREACH","text":"No available connection for the given optical reach was found\n\n\n\n\n\n","category":"constant"},{"location":"API/#MINDFul.ReturnCodes.FAIL_OPTICALREACH_OPTINIT","page":"API","title":"MINDFul.ReturnCodes.FAIL_OPTICALREACH_OPTINIT","text":"No available connection for the given optical reach, coming from an initiate optical constraint, was found\n\n\n\n\n\n","category":"constant"},{"location":"API/#MINDFul.ReturnCodes.FAIL_OPTICALREACH_OPTINIT_NONODESPLIT","page":"API","title":"MINDFul.ReturnCodes.FAIL_OPTICALREACH_OPTINIT_NONODESPLIT","text":"No available connection for the given optical reach, coming from an initiate optical constraint, was found\n\n\n\n\n\n","category":"constant"},{"location":"API/#MINDFul.ReturnCodes.FAIL_OPTICALREACH_OPTINIT_RETRY","page":"API","title":"MINDFul.ReturnCodes.FAIL_OPTICALREACH_OPTINIT_RETRY","text":"No available connection for the given optical reach, coming from an initiate optical constraint, was found even after retrying/recompiling\n\n\n\n\n\n","category":"constant"},{"location":"API/#MINDFul.ReturnCodes.FAIL_SAMEOXCLLI","page":"API","title":"MINDFul.ReturnCodes.FAIL_SAMEOXCLLI","text":"The same OXC LLI trying to be allocated already exists\n\n\n\n\n\n","category":"constant"},{"location":"API/#MINDFul.ReturnCodes.FAIL_SPECTRUM","page":"API","title":"MINDFul.ReturnCodes.FAIL_SPECTRUM","text":"No available spectrum was found\n\n\n\n\n\n","category":"constant"},{"location":"API/#MINDFul.ReturnCodes.FAIL_SPECTRUM_OPTINIT","page":"API","title":"MINDFul.ReturnCodes.FAIL_SPECTRUM_OPTINIT","text":"No available connection for the specturm slots, coming from an initiate optical constraint, was found\n\n\n\n\n\n","category":"constant"},{"location":"API/#MINDFul.ReturnCodes.FAIL_SRCOXCADDDROPPORT","page":"API","title":"MINDFul.ReturnCodes.FAIL_SRCOXCADDDROPPORT","text":"Source OXC Add/Drop port not found\n\n\n\n\n\n","category":"constant"},{"location":"API/#MINDFul.ReturnCodes.FAIL_SRCROUTERPORT","page":"API","title":"MINDFul.ReturnCodes.FAIL_SRCROUTERPORT","text":"No available router ports were found in source node\n\n\n\n\n\n","category":"constant"},{"location":"API/#MINDFul.ReturnCodes.FAIL_SRCTRANSMDL","page":"API","title":"MINDFul.ReturnCodes.FAIL_SRCTRANSMDL","text":"Source transmission module not found\n\n\n\n\n\n","category":"constant"},{"location":"API/#MINDFul.ReturnCodes.SUCCESS","page":"API","title":"MINDFul.ReturnCodes.SUCCESS","text":"Signifies everything worked as planned\n\n\n\n\n\n","category":"constant"},{"location":"API/#Public-HTTP-codes","page":"API","title":"Public HTTP codes","text":"","category":"section"},{"location":"API/#MINDFul.HTTPMessages","page":"API","title":"MINDFul.HTTPMessages","text":"The HTTP codes and data defined for the different requests.    All the const variables have a String value that represents the endpoint of the URL or the data that is passed respectively.    With full permission, the domains can access all the functions of the remote IBN framework.    With limited permission, the domains can only access the defined limited set of functions.\n\n\n\n\n\n","category":"module"},{"location":"API/#Non-public-interface","page":"API","title":"Non-public interface","text":"","category":"section"},{"location":"API/#MINDFul.OxygenServer","page":"API","title":"MINDFul.OxygenServer","text":"The type of the HTTP server used in the IBN Framework depends on whether the encryption is used or not.\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.AbstractIBNFHandler","page":"API","title":"MINDFul.AbstractIBNFHandler","text":"A handler or API for IBNFrameworks to talk to each other\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.AbstractIntent","page":"API","title":"MINDFul.AbstractIntent","text":"abstract type AbstractIntent\n\nA concrete subtype of AbstractIntent must implement the following methods: \n\nis_low_level_intent\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.AbstractIntentConstraint","page":"API","title":"MINDFul.AbstractIntentConstraint","text":"Special requirements for an intent (such as QoS)\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.AbstractOperationMode","page":"API","title":"MINDFul.AbstractOperationMode","text":"How the IBN frameworks operates generally.  It has effect of the available compilation algorithms In the future it could also have effect on different intent state machines\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.AbstractSDNController","page":"API","title":"MINDFul.AbstractSDNController","text":"The abstract type of the SDN controllers\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.AvailabilityConstraint","page":"API","title":"MINDFul.AvailabilityConstraint","text":"struct AvailabilityConstraint <: MINDFul.AbstractIntentConstraint\n\navailabilityrequirement::Float64: A float between 0 and 1 for the desired availability\ncompliancetarget::Float64: A float between 0 and 1 expressing the desired probability to cover the availability requirement\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.BasicAlgorithmMemory","page":"API","title":"MINDFul.BasicAlgorithmMemory","text":"mutable struct BasicAlgorithmMemory\n\ndatetime::Dates.DateTime: The simulated (or not) current datetime. It's used by the algorithm to build the uptime/downtime data\n\nlogintrapaths::Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, Dict{Vector{Vector{Int64}}, Int64}}: Log here the selection of (protection) path for an intra node (+ border) intent after install. Add new elements upon installation A new path Vector{Vector{LocalNode}} is added per node pair and counted how many times was it used\n\nloginterupdowntimes::Dict{MINDFul.GlobalEdge, Dict{Base.UUID, MINDFul.UpDownTimesNDatetime}}: Log here the up/downtimes of border-node to cross node. Add new elements upon installation. Update entries upon compilation. All UUIDs correspond to Remote Connectivity intents\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.BestEmpiricalAvailabilityCompilation","page":"API","title":"MINDFul.BestEmpiricalAvailabilityCompilation","text":"mutable struct BestEmpiricalAvailabilityCompilation <: MINDFul.IntentCompilationAlgorithmWithMemory\n\ncandidatepathsnum::Int64: How many k paths to check\npathsforprotectionnum::Int64: How many m paths to consider for joint protection. It investigates all possible pair of the first m paths\n\ncachedresults::MINDFul.CachedResults: cached information\nbasicalgmem::MINDFul.BasicAlgorithmMemory: The algorithm memory that is updated\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.BoolLogState","page":"API","title":"MINDFul.BoolLogState","text":"Stores a vector of the history of the boolean states and their timings\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.CachedResults","page":"API","title":"MINDFul.CachedResults","text":"struct CachedResults\n\nibnagweights::Matrix{Unitful.Quantity{Float64, 𝐋, Unitful.FreeUnits{(km,), 𝐋, nothing}}}\nyenpathsdict::Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, Vector{Vector{Int64}}}\nyenpathsdistsdict::Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, Vector{Unitful.Quantity{Float64, 𝐋, Unitful.FreeUnits{(km,), 𝐋, nothing}}}}\n\nUsed for every intent compilation algorithm satisfying the template to cache and not recalculate results.\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.ConnectivityIntent","page":"API","title":"MINDFul.ConnectivityIntent","text":"struct ConnectivityIntent{T<:MINDFul.AbstractIntentConstraint} <: MINDFul.AbstractIntent\n\nsourcenode::MINDFul.GlobalNode: Source node\ndestinationnode::MINDFul.GlobalNode: Destination node\nrate::Unitful.Quantity{Float64, Data 𝐓^-1, Unitful.FreeUnits{(Gbps,), Data 𝐓^-1, nothing}}: Bandwidth request value (Gbps)\nconstraints::Vector{T} where T<:MINDFul.AbstractIntentConstraint: Constraints for the Connecivity intent\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.CrossLightpathIntent","page":"API","title":"MINDFul.CrossLightpathIntent","text":"struct CrossLightpathIntent{C1<:MINDFul.ConnectivityIntent, C2<:MINDFul.ConnectivityIntent} <: MINDFul.AbstractIntent\n\nlightpathconnectivityintent::MINDFul.ConnectivityIntent\nremoteconnectivityintent::MINDFul.ConnectivityIntent\n\nThe only intent that is being built from its children to be offered as a straight grooming possibility. It is composed by a LightpathIntent and a RemoteIntent which are also its children intents.\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.DefaultOperationMode","page":"API","title":"MINDFul.DefaultOperationMode","text":"Default operation mode defined in MINDFul.jl\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.EdgeProperties","page":"API","title":"MINDFul.EdgeProperties","text":"struct EdgeProperties\n\ndistance::Unitful.Quantity{Float64, 𝐋, Unitful.FreeUnits{(km,), 𝐋, nothing}}: The distance of the edge (assumed km)\n\nAn immutable description of the edge properties\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.EdgeView","page":"API","title":"MINDFul.EdgeView","text":"struct EdgeView\n\nedgeproperties::MINDFul.EdgeProperties: The EdgeProperties\n\nThe view of the current edge settings\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.EndNodeAllocations","page":"API","title":"MINDFul.EndNodeAllocations","text":"struct EndNodeAllocations\n\nlocalnode::Int64\nrouterportindex::Union{Nothing, Int64}\ntransmissionmoduleviewpoolindex::Union{Nothing, Int64}\ntransmissionmodesindex::Union{Nothing, Int64}\nlocalnode_input::Union{Nothing, Int64}\nadddropport::Union{Nothing, Int64}\n\nBasically an aggregator of RouterPortLLI, TransmissionModuleLLI, OXCAddDropBypassSpectrumLLI in a node.\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.GlobalNode","page":"API","title":"MINDFul.GlobalNode","text":"struct GlobalNode\n\nibnfid::Base.UUID: IBN Framework id\nlocalnode::Int64: Node number\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.IBNAttributeGraph","page":"API","title":"MINDFul.IBNAttributeGraph","text":"The graph of the IBN Framework is expressed with this `AttributeGraph`.\nBorder nodes are assumed to be visible from both sides.\nHowever only the official owner can issue an intent.\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.IBNFCommunication","page":"API","title":"MINDFul.IBNFCommunication","text":"mutable struct IBNFCommunication{H<:MINDFul.AbstractIBNFHandler}\n\nserver::Union{Nothing, HTTP.Servers.Server{HTTP.Servers.Listener{Nothing, Sockets.TCPServer}}, HTTP.Servers.Server{HTTP.Servers.Listener{MbedTLS.SSLConfig, Sockets.TCPServer}}}\nibnfhandlers::Vector{H} where H<:MINDFul.AbstractIBNFHandler\n\nServer is of type Union{Nothing, OxygenServer} to allow for the server to be started later.\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.IBNFramework","page":"API","title":"MINDFul.IBNFramework","text":"struct IBNFramework{O<:MINDFul.AbstractOperationMode, S<:MINDFul.AbstractSDNController, T<:(AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView), I<:MINDFul.IBNFCommunication, R<:MINDFul.IntentCompilationAlgorithm} <: MINDFul.AbstractIBNFHandler\n\noperationmode::MINDFul.AbstractOperationMode: The operation mode of the IBN framework\nibnfid::Base.UUID: The id of this IBN Framework instance\nintentdag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo}: The intent dag tree that contains all intents (can be disconnected graph)\nibnag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView: Single-domain internal graph with border nodes included\nibnfcomm::MINDFul.IBNFCommunication: Other IBN Frameworks handles\nsdncontroller::MINDFul.AbstractSDNController: SDN controller handle\nintcompalg::MINDFul.IntentCompilationAlgorithm: Intent compilation algorithm\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.IBNFramework-Union{Tuple{R}, Tuple{S}, Tuple{H}, Tuple{T}, Tuple{T, Vector{H}, Bool, Vector{String}, S, R}, Tuple{T, Vector{H}, Bool, Vector{String}, S, R, Dict{Int64, MINDFul.IBNFramework}}} where {T<:(AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView), H<:MINDFul.AbstractIBNFHandler, S<:MINDFul.AbstractSDNController, R<:MINDFul.IntentCompilationAlgorithm}","page":"API","title":"MINDFul.IBNFramework","text":"IBNFramework(\n    ibnag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView,\n    ibnfhandlers::Array{H<:MINDFul.AbstractIBNFHandler, 1},\n    encryption::Bool,\n    ips::Vector{String},\n    sdncontroller::MINDFul.AbstractSDNController,\n    intcompalg::MINDFul.IntentCompilationAlgorithm;\n    ...\n) -> MINDFul.IBNFramework{MINDFul.DefaultOperationMode}\nIBNFramework(\n    ibnag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView,\n    ibnfhandlers::Array{H<:MINDFul.AbstractIBNFHandler, 1},\n    encryption::Bool,\n    ips::Vector{String},\n    sdncontroller::MINDFul.AbstractSDNController,\n    intcompalg::MINDFul.IntentCompilationAlgorithm,\n    ibnfsdict::Dict{Int64, MINDFul.IBNFramework};\n    verbose\n) -> MINDFul.IBNFramework{MINDFul.DefaultOperationMode}\n\n\nConstructor that specify IBNFHandlers to make it potentially type stable\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.IBNFramework-Union{Tuple{T}, Tuple{T, MINDFul.IntentCompilationAlgorithm}} where T<:(AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView)","page":"API","title":"MINDFul.IBNFramework","text":"IBNFramework(\n    ibnag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView,\n    intcompalg::MINDFul.IntentCompilationAlgorithm\n) -> MINDFul.IBNFramework{MINDFul.DefaultOperationMode, MINDFul.SDNdummy, T, I} where {T<:(AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView), I<:(MINDFul.IBNFCommunication{H} where H<:(MINDFul.IBNFramework{MINDFul.DefaultOperationMode, MINDFul.SDNdummy}))}\n\n\nThe most default construct with abstract type of IBN handlers\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.IBNIssuer","page":"API","title":"MINDFul.IBNIssuer","text":"struct IBNIssuer <: MINDFul.IntentIssuer\n\nIntent is issued by an IBN Framework domain\n\nibnfid::Base.UUID: the id of the IBNF issued the intent\nidagnodeid::Base.UUID: The id of the intent node in the DAG. The issuer of this intent node points back in this IBNIssuer instance.\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.IntentCompilationAlgorithm","page":"API","title":"MINDFul.IntentCompilationAlgorithm","text":"Instances of this specify how to compile the intent\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.IntentCompilationAlgorithmWithMemory","page":"API","title":"MINDFul.IntentCompilationAlgorithmWithMemory","text":"Compilation algorithm with some memory\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.IntentDAG","page":"API","title":"MINDFul.IntentDAG","text":"An AttributeGraph graph used as an intent Directed Acyclic Graph (DAG)\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.IntentDAGInfo","page":"API","title":"MINDFul.IntentDAGInfo","text":"mutable struct IntentDAGInfo\n\nintentcounter::Int64: The counter of the number of intents to give increasing ids to intents\ninstalledlightpaths::Dict{Base.UUID, MINDFul.LightpathRepresentation}: Logical representation of the installed intents as lightpaths (must be direct parent of the LLIs)\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.IntentDAGInfo-Tuple{}","page":"API","title":"MINDFul.IntentDAGInfo","text":"IntentDAGInfo() -> MINDFul.IntentDAGInfo\n\n\nEmpty constructor \n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.IntentDAGNode","page":"API","title":"MINDFul.IntentDAGNode","text":"struct IntentDAGNode{I<:MINDFul.AbstractIntent, II<:MINDFul.IntentIssuer}\n\nintent::MINDFul.AbstractIntent: The intent itself\nidagnodeid::Base.UUID: The id of the intent w.r.t. the intent DAG it belongs\nintentissuer::MINDFul.IntentIssuer: The intent issuer\nlogstate::Vector{Tuple{Dates.DateTime, MINDFul.IntentState.T}}: The history of states of the intent with the last being the current state\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.IntentIssuer","page":"API","title":"MINDFul.IntentIssuer","text":"Characterizes the entity issuing an intent\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.IntentLogState","page":"API","title":"MINDFul.IntentLogState","text":"IntentLogState(\n\n) -> Vector{Tuple{Dates.DateTime, MINDFul.IntentState.T}}\nIntentLogState(\n    intentstate::MINDFul.IntentState.T\n) -> Vector{Tuple{Dates.DateTime, MINDFul.IntentState.T}}\nIntentLogState(\n    intentstate::MINDFul.IntentState.T,\n    logtime::Dates.DateTime\n) -> Vector{Tuple{Dates.DateTime, MINDFul.IntentState.T}}\n\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.IntentLogState-2","page":"API","title":"MINDFul.IntentLogState","text":"Stores a vector of the history of the intent states and their timings\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.IntentLogStateTuple","page":"API","title":"MINDFul.IntentLogStateTuple","text":"Stores a single log element for the intent state and time\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.KShorestPathFirstFitCompilation","page":"API","title":"MINDFul.KShorestPathFirstFitCompilation","text":"struct KShorestPathFirstFitCompilation <: MINDFul.IntentCompilationAlgorithmWithMemory\n\ncandidatepathsnum::Int64: How many k paths to check\ncachedresults::MINDFul.CachedResults\nbasicalgmem::MINDFul.BasicAlgorithmMemory\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.KShorestPathFirstFitCompilation-Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView, Int64}","page":"API","title":"MINDFul.KShorestPathFirstFitCompilation","text":"KShorestPathFirstFitCompilation(\n    ibnag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView,\n    candidatepathnum::Int64\n) -> MINDFul.KShorestPathFirstFitCompilation\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.LightpathIntent","page":"API","title":"MINDFul.LightpathIntent","text":"struct LightpathIntent <: MINDFul.AbstractIntent\n\nsourcenodeallocations::MINDFul.EndNodeAllocations\ndestinationnodeallocations::MINDFul.EndNodeAllocations\nspectrumslotsrange::UnitRange{Int64}\npath::Vector{Int64}\n\nBasicaly an aggregator of LowLevelIntents. One lightpath intent can translate trivially to LowLevelIntents. It's core use is for grooming, where several Connectivity Intents can be linked to one LightpathIntent If the field does not apply, put 0\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.LightpathRepresentation","page":"API","title":"MINDFul.LightpathRepresentation","text":"struct LightpathRepresentation\n\npath::Vector{Vector{Int64}}: The nodes comprising the lightpath\nstartsoptically::Bool: true if it starts optically (due to OpticalInitiateConstraint) or false otherwise\nterminatessoptically::Bool: true if it terminates optically (due to OpticalTerminateConstraint) or false otherwise\ntotalbandwidth::Unitful.Quantity{Float64, Data 𝐓^-1, Unitful.FreeUnits{(Gbps,), Data 𝐓^-1, nothing}}: total bandwidth that can be allocated\ndestinationnode::MINDFul.GlobalNode: final node of the signal entering this lightpath. This could be a GlobalNode intrnally in the domain for a single lightpath. Or an external GlobalNode in a different domain for a cross-lightpath. In the second case, the signal might go over different lightpaths to reach the destination.\n\nRepresents an implementation of a ConnectivityIntent as a lightpath\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.LocalNode","page":"API","title":"MINDFul.LocalNode","text":"Signifies a local node notation as a single integer\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.LowLevelIntent","page":"API","title":"MINDFul.LowLevelIntent","text":"abstract type LowLevelIntent <: MINDFul.AbstractIntent\n\nAn abstract subtype of AbstractIntent notating device-level intents and should return is_low_level_intent to be true\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.MachineGenerated","page":"API","title":"MINDFul.MachineGenerated","text":"Intent is generated automatically by the IBN Framework\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.NetworkOperator","page":"API","title":"MINDFul.NetworkOperator","text":"Intent issued directly by the network operator, i.e., a user intent\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.NoGroomingConstraint","page":"API","title":"MINDFul.NoGroomingConstraint","text":"struct NoGroomingConstraint <: MINDFul.AbstractIntentConstraint\n\nConstraint that requires the intent is compiled without use of grooming techniques.\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.NodeProperties","page":"API","title":"MINDFul.NodeProperties","text":"struct NodeProperties\n\nlocalnode::Int64\nglobalnode::MINDFul.GlobalNode\nlatitude::Float64\nlongitude::Float64\ninneighbors::Vector{Int64}: The list of neighbohrs coming in\noutneighbors::Vector{Int64}: The list of neighbohrs going out\n\nAn immutable description of the node properties\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.NodeView","page":"API","title":"MINDFul.NodeView","text":"struct NodeView{R<:MINDFul.RouterView, O<:MINDFul.OXCView, T<:MINDFul.TransmissionModuleView} <: MINDFul.ReservableResourceView\n\nnodeproperties::MINDFul.NodeProperties: The NodeProperties\nrouterview::Union{Nothing, R} where R<:MINDFul.RouterView: The router in use\noxcview::Union{Nothing, O} where O<:MINDFul.OXCView: The OXC in use\ntransmissionmoduleviewpool::Union{Nothing, Vector{T}} where T<:MINDFul.TransmissionModuleView: The transmission modules contained\ntransmissionmodulereservations::Union{Nothing, Dict{Base.UUID, MINDFul.TransmissionModuleLLI}}: intent reservation of the transmission modules\ntransmissionmodulestaged::Union{Nothing, Set{MINDFul.TransmissionModuleLLI}}: intent staged of the transmission modules\n\nThe view of the current node settings Reservables resources reservations are nothing if it represents a border node.\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.OXCAddDropBypassSpectrumLLI","page":"API","title":"MINDFul.OXCAddDropBypassSpectrumLLI","text":"struct OXCAddDropBypassSpectrumLLI <: MINDFul.LowLevelIntent\n\nlocalnode::Int64: Target node\nlocalnode_input::Int64: The node in graph entering the OXC (or 0 if invalid)\nadddropport::Int64: The port index adding or dropping an optical signal (or 0 if invalid)\nlocalnode_output::Int64: The node in graph exiting the OXC (or 0 if invalid)\nspectrumslotsrange::UnitRange{Int64}: The spectrum range allocated 1-based indexed\n\nA value-based interpretation of (input, adddrop, output). At least one of the 3 elements must be 0. (x, 0, y) means optical bypass from the localnode x to the localnode y (0, x, y) means adding an optical signal from add port x going to the localnode y (x, y, 0) means droping an optical signal from  the localnode x to the drop port y (0, x, 0) mean that an add/drop allocation port is only reserved (is needed on top for an add/drop signal)\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.OXCView","page":"API","title":"MINDFul.OXCView","text":"struct OXCView{O<:MINDFul.AbstractOXC} <: MINDFul.ReservableResourceView\n\noxc::MINDFul.AbstractOXC: the underlying OXC\nadddropportnumber::Int64: The number of add/drop ports in OXC\nswitchreservations::Dict{Base.UUID, MINDFul.OXCAddDropBypassSpectrumLLI}: The intent reservations together with the configuration\nswitchstaged::Set{MINDFul.OXCAddDropBypassSpectrumLLI}: The intent staged together with the configuration\nlinkspectrumavailabilities::Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, Vector{Bool}}: Link spectrum availability total view in sync with switchreservations. A vector showing the availability of the spectrum slots. true for available and false for reserved. The vector views should be the same with the ones on the opposite OXC view.\n\nlinkstates::Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, Vector{Tuple{Dates.DateTime, Bool}}}: History information of the status of the connected links (working or not). The last element is the current state.\n\nA view of a OXC. This OXC view is also a view to the links connecting to the OXC. Since links are not devices under control, MINDFul does not model them directly.\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.OpticalInitiateConstraint","page":"API","title":"MINDFul.OpticalInitiateConstraint","text":"struct OpticalInitiateConstraint <: MINDFul.AbstractIntentConstraint\n\nConstraint that requires the intent to initiate optically. It's combined with an (@ref)[OpticalTerminateConstraint] before. It contains some requirements for the connection to work out.\n\nglobalnode_input::MINDFul.GlobalNode: The incoming border node entering the OXC\nspectrumslotsrange::UnitRange{Int64}: The spectrum range allocated 1-based indexed\nopticalreach::Unitful.Quantity{Float64, 𝐋, Unitful.FreeUnits{(km,), 𝐋, nothing}}: the remaining optical reach to use\ntransmissionmodulecompat::MINDFul.TransmissionModuleCompatibility: Requirements for termination in the electical layer\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.OpticalTerminateConstraint","page":"API","title":"MINDFul.OpticalTerminateConstraint","text":"struct OpticalTerminateConstraint <: MINDFul.AbstractIntentConstraint\n\nConstraint that requires the intent to terminate optically one node before the destination. It's combined with an (@ref)[OpticalInitiateConstraint] after.\n\nfinaldestination::MINDFul.GlobalNode: The final destination (intra domain or inter-domain) Used primarily for grooming cross lightpaths.\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.ProtectedLightpathIntent","page":"API","title":"MINDFul.ProtectedLightpathIntent","text":"struct ProtectedLightpathIntent <: MINDFul.AbstractIntent\n\nprsourcenodeallocations::Vector{MINDFul.EndNodeAllocations}\nprdestinationnodeallocations::Vector{MINDFul.EndNodeAllocations}\nprspectrumslotsrange::Vector{UnitRange{Int64}}\nprpath::Vector{Vector{Int64}}\n\nAn accumulation of lightpaths such that they get protected It's being translated down to many Lightpath intents that have certain LLIs groomed with one another Furthermore, only one lightpath is installed and the others are staged. In case of a failure a different working lightpath will be installed instead\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.RemoteHTTPHandler","page":"API","title":"MINDFul.RemoteHTTPHandler","text":"mutable struct RemoteHTTPHandler <: MINDFul.AbstractIBNFHandler\n\nibnfid::Base.UUID\nbaseurl::String\npermission::String\nrsakey::String\nrsasecret::String\ngentoken::String\nrecvtoken::String\n\nA single token is generated per directed pair. The permission is referring to the genenerated token (gentoken). gentoken and recvtoken are not constant as they will be generated when the handshake is done. rsakey contains the private key if the handler belongs to the local domain. If the handler is for a remote domain, it contains the public key of that domain. The secret is used to authenticate the initiator domain and it is also generated during the handshake.\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.RemoteIntent","page":"API","title":"MINDFul.RemoteIntent","text":"struct RemoteIntent{I<:MINDFul.AbstractIntent} <: MINDFul.AbstractIntent\n\nibnfid::Base.UUID: The id of the remote IBN framework\nidagnodeid::Base.UUID: The dag node id of the remote IBN framework\nintent::MINDFul.AbstractIntent: The intent to be transferred\nisinitiator::Bool: true if the intent originates here and false otherwise\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.ReservableResourceView","page":"API","title":"MINDFul.ReservableResourceView","text":"The following functions should be implemented for subtypes:\n\ngetreservations(subtype::ReservableResourceView)::Set{T}\ncanreserve(subtype::ReservableResourceView, reservation::T)::Bool\n\nThe following default functions exist that should already work\n\nreserve!(subtype::ReservableResourceView, dagnodeid::UUID, reservation::T; checkfirst::Bool=true)::Bool\nunreserve!(subtype::ReservableResourceView, dagnodeid::UUID)::Bool\ninsertreservation!(subtype::ReservableResourceView, dagnodeid::UUID, reservation::T)\ndeletereservation!(subtype::ReservableResourceView, dagnodeid::UUID)\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.ReturnCodeTime","page":"API","title":"MINDFul.ReturnCodeTime","text":"struct ReturnCodeTime\n\nreturncode::Symbol\ndatetime::Dates.DateTime\n\nWhat most time-sensitive functions return\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.ReturnUUIDTime","page":"API","title":"MINDFul.ReturnUUIDTime","text":"struct ReturnUUIDTime\n\nuuid::Base.UUID\ndatetime::Dates.DateTime\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.RouterPort","page":"API","title":"MINDFul.RouterPort","text":"struct RouterPort\n\nA representation of a router port.\n\nrate::Unitful.Quantity{Float64, Data 𝐓^-1, Unitful.FreeUnits{(Gbps,), Data 𝐓^-1, nothing}}\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.RouterPortLLI","page":"API","title":"MINDFul.RouterPortLLI","text":"struct RouterPortLLI <: MINDFul.LowLevelIntent\n\nlocalnode::Int64: Target node\nrouterportindex::Int64: The router port index to be reserved\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.RouterView","page":"API","title":"MINDFul.RouterView","text":"struct RouterView{R<:MINDFul.AbstractRouter} <: MINDFul.ReservableResourceView\n\nA view of a router with several ports.\n\nrouter::MINDFul.AbstractRouter: The underlying router\nports::Vector{MINDFul.RouterPort}: number of ports in router\nportreservations::Dict{Base.UUID, MINDFul.RouterPortLLI}: The intent reservations together with the low level intent of reserved port\nportstaged::Set{MINDFul.RouterPortLLI}: The intent reservations together with the low level intent of a staged port\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.SDNdummy","page":"API","title":"MINDFul.SDNdummy","text":"struct SDNdummy <: MINDFul.AbstractSDNController\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.SplitGlobalNode","page":"API","title":"MINDFul.SplitGlobalNode","text":"struct SplitGlobalNode\n\nglobalnode::MINDFul.GlobalNode\nfirsthalfavailabilityconstraint::Union{Nothing, MINDFul.AvailabilityConstraint}\nsecondhalfavailabilityconstraint::Union{Nothing, MINDFul.AvailabilityConstraint}\n\nThe return value from the prioritizesplitnode and prioritizesplitbordernode functions\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.SplitGlobalNode-Tuple{MINDFul.GlobalNode}","page":"API","title":"MINDFul.SplitGlobalNode","text":"SplitGlobalNode(\n    globalnode::MINDFul.GlobalNode\n) -> MINDFul.SplitGlobalNode\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.TransmissionMode","page":"API","title":"MINDFul.TransmissionMode","text":"struct TransmissionMode\n\nRepresents a transmission mode. A transponder, if flexible, might support many of them.\n\nopticalreach::Unitful.Quantity{Float64, 𝐋, Unitful.FreeUnits{(km,), 𝐋, nothing}}: Optical reach in kilometers\nrate::Unitful.Quantity{Float64, Data 𝐓^-1, Unitful.FreeUnits{(Gbps,), Data 𝐓^-1, nothing}}: rate in Gbps\nspectrumslotsneeded::Int64: Number of 12.5 GHz frequency slots needed\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.TransmissionModuleCompatibility","page":"API","title":"MINDFul.TransmissionModuleCompatibility","text":"struct TransmissionModuleCompatibility\n\nrouterportrate::Union{Nothing, Unitful.Quantity{Float64, Data 𝐓^-1, Unitful.FreeUnits{(Gbps,), Data 𝐓^-1, nothing}}}: The router port rate (maximum). If it's nothing it means it's already resolved and trusted.\nrate::Unitful.Quantity{Float64, Data 𝐓^-1, Unitful.FreeUnits{(Gbps,), Data 𝐓^-1, nothing}}: The bandwidth of the connection\nspectrumslotsneeded::Int64: Number of 12.5Gz frequency slots needed\nname::String: descriptive name of the transmission module\n\nDescribe what requirements are needed to establish transmission module end-to-end connection Modulation should be here but it's not. Dissagregetation data should be here but it's not. Both are covered by the name which must be equal in both ends\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.TransmissionModuleIntent","page":"API","title":"MINDFul.TransmissionModuleIntent","text":"struct TransmissionModuleIntent <: MINDFul.AbstractIntent\n\nContains the requirements to compile down to TransmissionModuleLLI\n\nrate::Unitful.Quantity{Float64, Data 𝐓^-1, Unitful.FreeUnits{(Gbps,), Data 𝐓^-1, nothing}}: The data rate requierement\nopticalreach::Unitful.Quantity{Float64, 𝐋, Unitful.FreeUnits{(km,), 𝐋, nothing}}: Optical reach requirements in kilometres\nspectrumslotsneeded::Int64: Number of 12.5 GHz frequency slots needed\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.TransmissionModuleLLI","page":"API","title":"MINDFul.TransmissionModuleLLI","text":"struct TransmissionModuleLLI <: MINDFul.LowLevelIntent\n\nlocalnode::Int64: Target node\ntransmissionmoduleviewpoolindex::Int64: The index of the transmission module pool to be reserved\ntransmissionmodesindex::Int64: The selected mode of the transmission module. 0 means nothing is still selected. Non elastic modules can have only 1.\nrouterportindex::Int64: The router port index to be connected\nadddropport::Int64: The port index adding or dropping the optical signal to be connected\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.TransmissionModuleView","page":"API","title":"MINDFul.TransmissionModuleView","text":"struct TransmissionModuleView{T<:MINDFul.AbstractTransmissionModule}\n\ntransmissionmodule::MINDFul.AbstractTransmissionModule: The underlying transmission module\nname::String: descriptive name of the transmission module\ntransmissionmodes::Vector{MINDFul.TransmissionMode}: operating transmission modes\ncost::Float64: Cost of the transmission module (in unit costs)\n\nA view of a transmission module.\n\n\n\n\n\n","category":"type"},{"location":"API/#Base.show-Union{Tuple{I}, Tuple{IO, I}} where I<:MINDFul.IBNFramework","page":"API","title":"Base.show","text":"show(io::IO, ibnf::MINDFul.IBNFramework)\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul._rec_deletenodesedgesuntilgroomingfound!-Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo}, Base.UUID, Vector{Base.UUID}}","page":"API","title":"MINDFul._rec_deletenodesedgesuntilgroomingfound!","text":"_rec_deletenodesedgesuntilgroomingfound!(\n    idag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo},\n    idagnodeid::Base.UUID,\n    idagnodeid2dlt::Vector{Base.UUID}\n) -> Bool\n\n\nReturns true if grooming is found and the idagnodeid to delete\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.addidagedge!-Tuple{MINDFul.IBNFramework, Base.UUID, Base.UUID}","page":"API","title":"MINDFul.addidagedge!","text":"addidagedge!(\n    ibnf::MINDFul.IBNFramework,\n    fromnode::Base.UUID,\n    tonode::Base.UUID;\n    offsettime\n) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.addidagnode!-Tuple{MINDFul.IBNFramework, MINDFul.AbstractIntent}","page":"API","title":"MINDFul.addidagnode!","text":"addidagnode!(\n    ibnf::MINDFul.IBNFramework,\n    intent::MINDFul.AbstractIntent;\n    parentids,\n    childids,\n    intentissuer,\n    offsettime\n) -> MINDFul.IntentDAGNode{I, MINDFul.MachineGenerated} where I<:MINDFul.AbstractIntent\n\n\nReturn the IntentDAGNode\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.addidagnode!-Tuple{MINDFul.IBNFramework, MINDFul.IntentDAGNode}","page":"API","title":"MINDFul.addidagnode!","text":"addidagnode!(\n    ibnf::MINDFul.IBNFramework,\n    idagnode::MINDFul.IntentDAGNode;\n    parentids,\n    childids,\n    intentissuer\n) -> Base.UUID\n\n\nReturn the UUID\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.addkeywordparameters!-Tuple{Expr, Vararg{Expr}}","page":"API","title":"MINDFul.addkeywordparameters!","text":"addkeywordparameters!(\n    funcexpr::Expr,\n    keywordparexprs::Expr...\n) -> Expr\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.addtoinstalledlightpaths!-Tuple{MINDFul.IBNFramework, MINDFul.IntentDAGNode{<:MINDFul.ConnectivityIntent}}","page":"API","title":"MINDFul.addtoinstalledlightpaths!","text":"addtoinstalledlightpaths!(\n    ibnf::MINDFul.IBNFramework,\n    idagnode::MINDFul.IntentDAGNode{<:MINDFul.ConnectivityIntent}\n) -> Bool\n\n\nIf idagnode represents a direct parent of LLIs that are a lightpath, add representation to the IntentDAGInfo Return true if done. Otherwise false\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.addtoinstalledlightpaths!-Tuple{MINDFul.IBNFramework, MINDFul.IntentDAGNode{<:Union{MINDFul.LightpathIntent, MINDFul.CrossLightpathIntent}}}","page":"API","title":"MINDFul.addtoinstalledlightpaths!","text":"addtoinstalledlightpaths!(\n    ibnf::MINDFul.IBNFramework,\n    idagnode::MINDFul.IntentDAGNode{<:Union{MINDFul.LightpathIntent, MINDFul.CrossLightpathIntent}}\n) -> Bool\n\n\nIf idagnode represents a direct parent of LLIs that are a lightpath, add representation to the IntentDAGInfo Return true if done. Otherwise false\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.addtoinstalledlightpaths!-Tuple{MINDFul.IBNFramework, MINDFul.IntentDAGNode{MINDFul.ProtectedLightpathIntent}}","page":"API","title":"MINDFul.addtoinstalledlightpaths!","text":"addtoinstalledlightpaths!(\n    ibnf::MINDFul.IBNFramework,\n    idagnode::MINDFul.IntentDAGNode{MINDFul.ProtectedLightpathIntent}\n) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.allocate_oxcspectrumslots-Tuple{MINDFul.IBNFramework, Base.UUID, Int64}","page":"API","title":"MINDFul.allocate_oxcspectrumslots","text":"allocate_oxcspectrumslots(\n    ibnf::MINDFul.IBNFramework,\n    dagnodeid::Base.UUID,\n    localnode::Int64\n) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.allocate_transmissionmodule-Tuple{MINDFul.IBNFramework, Base.UUID, Int64, MINDFul.TransmissionModuleLLI}","page":"API","title":"MINDFul.allocate_transmissionmodule","text":"allocate_transmissionmodule(\n    ibnf::MINDFul.IBNFramework,\n    dagnodeid::Base.UUID,\n    localnode::Int64,\n    transmissionmodulereservationentry::MINDFul.TransmissionModuleLLI\n)\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.aretransmissionmodulescompatible-Tuple{MINDFul.TransmissionModuleView, MINDFul.TransmissionModuleView}","page":"API","title":"MINDFul.aretransmissionmodulescompatible","text":"aretransmissionmodulescompatible(\n    tmv1::MINDFul.TransmissionModuleView,\n    tmv2::MINDFul.TransmissionModuleView\n) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.calcintrasplitglobalnode-Tuple{MINDFul.IBNFramework, MINDFul.ConnectivityIntent, MINDFul.GlobalNode}","page":"API","title":"MINDFul.calcintrasplitglobalnode","text":"calcintrasplitglobalnode(\n    ibnf::MINDFul.IBNFramework,\n    intent::MINDFul.ConnectivityIntent,\n    splitglobalnodeonly::MINDFul.GlobalNode\n) -> MINDFul.SplitGlobalNode\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.calculatepathavailability-Tuple{Vector{Float64}}","page":"API","title":"MINDFul.calculatepathavailability","text":"calculatepathavailability(\n    availabilities::Vector{Float64}\n) -> Float64\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.calculateprotectedpathavailability-Tuple{Vector{Graphs.SimpleGraphs.SimpleEdge{Int64}}, Vector{Float64}, Vector{Graphs.SimpleGraphs.SimpleEdge{Int64}}, Vector{Float64}}","page":"API","title":"MINDFul.calculateprotectedpathavailability","text":"calculateprotectedpathavailability(\n    p1edges::Vector{Graphs.SimpleGraphs.SimpleEdge{Int64}},\n    p1avails::Vector{Float64},\n    p2edges::Vector{Graphs.SimpleGraphs.SimpleEdge{Int64}},\n    p2avails::Vector{Float64}\n) -> Float64\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.calculateprotectedpathavailability-Tuple{Vector{Vector{Graphs.SimpleGraphs.SimpleEdge{Int64}}}, Vector{Vector{Float64}}}","page":"API","title":"MINDFul.calculateprotectedpathavailability","text":"calculateprotectedpathavailability(\n    pedges::Vector{Vector{Graphs.SimpleGraphs.SimpleEdge{Int64}}},\n    pavails::Vector{Vector{Float64}}\n) -> Float64\n\n\nTODO : need to finish it if I ever use more than 2 protection paths\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.canreserve-Tuple{MINDFul.AbstractSDNController, MINDFul.NodeView, MINDFul.TransmissionModuleLLI}","page":"API","title":"MINDFul.canreserve","text":"canreserve(\n    sdn::MINDFul.AbstractSDNController,\n    nodeview::MINDFul.NodeView,\n    transmissionmodulelli::MINDFul.TransmissionModuleLLI;\n    verbose\n) -> Bool\n\n\nSet verbose=true to see where the reservation fails\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.canreserve-Tuple{MINDFul.AbstractSDNController, MINDFul.OXCView, MINDFul.OXCAddDropBypassSpectrumLLI}","page":"API","title":"MINDFul.canreserve","text":"canreserve(\n    sdn::MINDFul.AbstractSDNController,\n    oxcview::MINDFul.OXCView,\n    oxcswitchreservationentry::MINDFul.OXCAddDropBypassSpectrumLLI;\n    verbose\n) -> Bool\n\n\nCheck whether\n\nadd/drop port exists\nadd/drop port already in use\nspectrum in fibers in use\n\nSet verbose=true to see where the reservation fails\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.canreserve-Tuple{MINDFul.AbstractSDNController, MINDFul.RouterView, MINDFul.RouterPortLLI}","page":"API","title":"MINDFul.canreserve","text":"canreserve(\n    sdn::MINDFul.AbstractSDNController,\n    routerview::MINDFul.RouterView,\n    routerportlli::MINDFul.RouterPortLLI;\n    verbose\n) -> Bool\n\n\nCheck if router port exists and whether it is already used\n\nSet verbose=true to see where the reservation fails\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.checkfilepath-Tuple{String, String}","page":"API","title":"MINDFul.checkfilepath","text":"checkfilepath(\n    directoryname::String,\n    filepath::String\n) -> String\n\n\nFunction to check if a given file path is absolute or relative. If it is relative, it will be joined with the given directory name.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.checkifopensslinstalled-Tuple{}","page":"API","title":"MINDFul.checkifopensslinstalled","text":"checkifopensslinstalled() -> Bool\n\n\nFunction to check if openSSL is installed on the system. It runs the openssl version command and checks if it succeeds. If it fails, it prints an error message and exits.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.choosecrosssplitavailabilities-Tuple{MINDFul.AvailabilityConstraint, Any, Any, MINDFul.BestEmpiricalAvailabilityCompilation}","page":"API","title":"MINDFul.choosecrosssplitavailabilities","text":"choosecrosssplitavailabilities(\n    avcon::MINDFul.AvailabilityConstraint,\n    firsthalfavailability,\n    secondhalfavailability,\n    beacomp::MINDFul.BestEmpiricalAvailabilityCompilation\n) -> Tuple{MINDFul.AvailabilityConstraint, MINDFul.AvailabilityConstraint}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.choosecrosssplitavailabilities-Tuple{MINDFul.AvailabilityConstraint, Any, Any, MINDFul.IntentCompilationAlgorithm}","page":"API","title":"MINDFul.choosecrosssplitavailabilities","text":"choosecrosssplitavailabilities(\n    avcon::MINDFul.AvailabilityConstraint,\n    firsthalfavailability,\n    secondhalfavailability,\n    intentcomp::MINDFul.IntentCompilationAlgorithm\n) -> Tuple{MINDFul.AvailabilityConstraint, MINDFul.AvailabilityConstraint}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.choosegroominornot-Tuple{MINDFul.IBNFramework{A, B, C, D, MINDFul.BestEmpiricalAvailabilityCompilation} where {A, B, C, D}, Vector{Vector{Int64}}, Int64, Vector{Union{Base.UUID, Graphs.SimpleGraphs.SimpleEdge{Int64}}}}","page":"API","title":"MINDFul.choosegroominornot","text":"Choose exactly the grooming for protectedpaths If many  protectedpaths are passed, there can only be matched with a single protection lightpath intent that has the same paths If just one path is passed, it can be broken down to several lightpaths but that must have the same nodes.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.chooseintrasplitavailabilities-Tuple{MINDFul.AvailabilityConstraint, Any, Any, MINDFul.IntentCompilationAlgorithm}","page":"API","title":"MINDFul.chooseintrasplitavailabilities","text":"chooseintrasplitavailabilities(\n    avcon::MINDFul.AvailabilityConstraint,\n    firsthalfavailability,\n    secondhalfavailability,\n    intentcomp::MINDFul.IntentCompilationAlgorithm\n) -> Tuple{MINDFul.AvailabilityConstraint, MINDFul.AvailabilityConstraint}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.chooseintrasplitavailabilities-Tuple{MINDFul.AvailabilityConstraint, Distributions.DiscreteNonParametric, Distributions.DiscreteNonParametric, MINDFul.BestEmpiricalAvailabilityCompilation}","page":"API","title":"MINDFul.chooseintrasplitavailabilities","text":"chooseintrasplitavailabilities(\n    avcon::MINDFul.AvailabilityConstraint,\n    firsthalfavailability::Distributions.DiscreteNonParametric,\n    secondhalfavailability::Distributions.DiscreteNonParametric,\n    beacomp::MINDFul.BestEmpiricalAvailabilityCompilation\n) -> Tuple{MINDFul.AvailabilityConstraint, MINDFul.AvailabilityConstraint}\n\n\nquantile(::DiscreteNonParametric, q) gives smallest value x such that cdf(::DiscreteNonParatetric, x) >= q This means that there is x is the biggest value for q% of ::DiscreteNonParametric. For example, q=0.95 means that x will be bigger than 95% of the support of ::DiscreteNonParametric. cquantile is exactly the opposite implying that it would be smaller than 95% of the support. For example, now talking availability requirements and compliance targets,  \n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.chooseoxcadddropport_first-Tuple{MINDFul.IBNFramework, MINDFul.IntentDAGNode{<:MINDFul.ConnectivityIntent}, Int64}","page":"API","title":"MINDFul.chooseoxcadddropport_first","text":"chooseoxcadddropport_first(\n    ibnf::MINDFul.IBNFramework,\n    idagnode::MINDFul.IntentDAGNode{<:MINDFul.ConnectivityIntent},\n    node::Int64\n) -> Union{Nothing, Int64}\n\n\nReturn the uniformly random available oxc add/drop port and nothing if none found\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.choosespectrum_firstfit-Tuple{MINDFul.IBNFramework, MINDFul.IntentDAGNode{<:MINDFul.ConnectivityIntent}, Vector{Int64}, Int64}","page":"API","title":"MINDFul.choosespectrum_firstfit","text":"choosespectrum_firstfit(\n    ibnf::MINDFul.IBNFramework,\n    idagnode::MINDFul.IntentDAGNode{<:MINDFul.ConnectivityIntent},\n    path::Vector{Int64},\n    demandslotsneeded::Int64\n) -> Union{Nothing, Int64}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.closeibnfserver-Tuple{MINDFul.IBNFramework}","page":"API","title":"MINDFul.closeibnfserver","text":"closeibnfserver(ibnf::MINDFul.IBNFramework)\n\n\nFunction to gracefully close the server of an IBNFramework.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.compilegroomingpossibility-Union{Tuple{F}, Tuple{MINDFul.IBNFramework, MINDFul.IntentDAGNode{<:MINDFul.ConnectivityIntent}, Vector{Union{Base.UUID, Graphs.SimpleGraphs.SimpleEdge{Int64}}}, F, Dict{MINDFul.ConnectivityIntent, Symbol}}} where F<:Function","page":"API","title":"MINDFul.compilegroomingpossibility","text":"compilegroomingpossibility(\n    ibnf::MINDFul.IBNFramework,\n    idagnode::MINDFul.IntentDAGNode{<:MINDFul.ConnectivityIntent},\n    groomingpossibility::Vector{Union{Base.UUID, Graphs.SimpleGraphs.SimpleEdge{Int64}}},\n    intradomainalgfun::Function,\n    cachedintentresult::Dict{MINDFul.ConnectivityIntent, Symbol};\n    verbose,\n    offsettime\n) -> Symbol\n\n\nReturns ReturnCode on whether it managed to compile the grooming possibility passed.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.compileintenttemplate!-Union{Tuple{F4}, Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{MINDFul.IBNFramework, MINDFul.IntentDAGNode{<:MINDFul.ConnectivityIntent}}} where {F1<:Function, F2<:Function, F3<:Function, F4<:Function}","page":"API","title":"MINDFul.compileintenttemplate!","text":"compileintenttemplate!(\n    ibnf::MINDFul.IBNFramework,\n    idagnode::MINDFul.IntentDAGNode{<:MINDFul.ConnectivityIntent};\n    verbose,\n    intradomainalgfun,\n    prioritizegrooming,\n    prioritizesplitnodes,\n    prioritizesplitbordernodes,\n    cachedintentresult,\n    offsettime\n)\n\n\nA template compilation function that can be extended\n\nGive in the following hook functions:\n\nintradomainalgfun is used as compilation algorithm for the intents handled internally. \n\nIt should return a Symbol as a return code.  Common return codes are found in MINDFul.ReturnCodes\n\nintradomainalgfun(\n    ibnf::IBNFramework, \n    idagnode::IntentDAGNode{<:ConnectivityIntent},\n    ; datetime::DateTime\n) -> Symbol\n\nprioritizesplitnodes is called when optical reach is not enough to have a lightpath end-to-end to serve the intent and a path to split was already selected.\n\nThe node selected will break the intent into two pieces with the node standing in between. This function should return a vector of GlobalNodes with decreasing priority of which node should be chosen.\n\nprioritizesplitnodes(\n    ibnf::IBNFramework,\n    idagnode::IntentDAGNode,\n) -> Vector{GlobalNode}\n\nprioritizesplitbordernodes is called to select the border node to work as the source node for the delegated intent in a neighboring domain.\n\nThis function should return a vector of SplitGlobalNodes with decreasing priority of which node should be chosen.\n\nprioritizesplitbordernodes(\n    ibnf::IBNFramework,\n    idagnode::IntentDAGNode{<:ConnectivityIntent},\n) -> Vector{GlobalNode}\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.consecutivelightpathsidx-Tuple{Vector{Vector{Int64}}, Int64}","page":"API","title":"MINDFul.consecutivelightpathsidx","text":"Pass a `Vector{Vector{Int}}` where `Int` are the nodes of each lightpath.\nReturn a `Vector{Vector{Int}}` where `Int` is the index of the contained lightpaths.\nif `startingnode = true`, `node` is starting else is ending.\n\njulia> MINDF.consecutivelightpathsidx([\n       [1,3,7], #1\n       [2,5,7], #2\n       [2,8,9], #3\n       [7,4,2]\n       ], 1; startingnode=true)\n3-element Vector{Vector{Int64}}:\n [1]\n [1, 4]\n [1, 4, 3]\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.consecutivelightpathsidx-Tuple{Vector{Vector{Int64}}, Vector{Int64}}","page":"API","title":"MINDFul.consecutivelightpathsidx","text":"Return all possible combination of the lightpath indices passed such that `path` is formed\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.construct_BoolLogState","page":"API","title":"MINDFul.construct_BoolLogState","text":"construct_BoolLogState(\n\n) -> Vector{Tuple{Dates.DateTime, Bool}}\nconstruct_BoolLogState(\n    offsettime\n) -> Vector{T} where T<:Tuple{Any, Bool}\nconstruct_BoolLogState(\n    offsettime,\n    initialstate\n) -> Vector{<:Tuple{Any, Any}}\n\n\nImplementing BoolLogState() is type piracy.\n\n\n\n\n\n","category":"function"},{"location":"API/#MINDFul.constructfromdict-Union{Tuple{T}, Tuple{Type{T}, Dict{Symbol}, Dict{Symbol}}} where T","page":"API","title":"MINDFul.constructfromdict","text":"constructfromdict(\n    _::Type{T},\n    dict::Dict{Symbol},\n    dict2::Dict{Symbol}\n) -> MINDFul.NodeProperties\n\n\nConvenience function to construct any struct of type T by passing a Dict corresponding to the fields needed. A further dict dict2 is searched for data.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.constructfromdict-Union{Tuple{T}, Tuple{Type{T}, Dict{Symbol}}} where T","page":"API","title":"MINDFul.constructfromdict","text":"constructfromdict(\n    _::Type{T},\n    dict::Dict{Symbol}\n) -> MINDFul.EdgeProperties\n\n\nusing Core: ReturnNode\n\nConvenience function to construct any struct of type T by passing a Dict corresponding to the fields needed.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.convertb64keytopem-Tuple{String, String}","page":"API","title":"MINDFul.convertb64keytopem","text":"convertb64keytopem(\n    keyb64::String,\n    typeofkey::String\n) -> String\n\n\nFunction to convert a base64 encoded key to PEM format. The typeofkey parameter should be either \"PUBLIC KEY\" or \"PRIVATE KEY\".\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.createmultidomainIBNAttributeGraph-Tuple{MINDFul.IBNFramework}","page":"API","title":"MINDFul.createmultidomainIBNAttributeGraph","text":"createmultidomainIBNAttributeGraph(\n    ibnf::MINDFul.IBNFramework\n) -> AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView\n\n\nConstruct a IBNAttributeGraph representation for all mutli-domain network from the IBNFramework neighboring interIBNF ATTENTION: the inner graph data are still representing information internally per domain.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.deallocate_transmissionmodule-Tuple{MINDFul.IBNFramework, Int64, MINDFul.TransmissionModuleLLI}","page":"API","title":"MINDFul.deallocate_transmissionmodule","text":"deallocate_transmissionmodule(\n    ibnf::MINDFul.IBNFramework,\n    localnode::Int64,\n    transmissionmodulereservationentry::MINDFul.TransmissionModuleLLI\n) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.default_OXCview","page":"API","title":"MINDFul.default_OXCview","text":"default_OXCview(\n    nodeproperties::MINDFul.NodeProperties,\n    spectrumslots::Int64\n) -> MINDFul.OXCView{MINDFul.OXCDummy}\ndefault_OXCview(\n    nodeproperties::MINDFul.NodeProperties,\n    spectrumslots::Int64,\n    offsettime\n) -> MINDFul.OXCView{MINDFul.OXCDummy}\n\n\n\n\n\n\n","category":"function"},{"location":"API/#MINDFul.deleteedgesuntilgroomingfound!-Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo}, Base.UUID}","page":"API","title":"MINDFul.deleteedgesuntilgroomingfound!","text":"deleteedgesuntilgroomingfound!(\n    idag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo},\n    idagnodeid::Base.UUID\n)\n\n\nDelete edges towards grooming nodes.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.deletenodesedgesuntilgroomingfound-Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo}, Base.UUID}","page":"API","title":"MINDFul.deletenodesedgesuntilgroomingfound","text":"deletenodesedgesuntilgroomingfound(\n    idag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo},\n    idagnodeid::Base.UUID\n)\n\n\nDelete all nodes and edges until the grooming node is found. If no grooming node is found, delete nothing. Start from idagnodeid\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.deletereservation!-Tuple{MINDFul.AbstractSDNController, MINDFul.ReservableResourceView, Base.UUID}","page":"API","title":"MINDFul.deletereservation!","text":"deletereservation!(\n    sdn::MINDFul.AbstractSDNController,\n    resourceview::MINDFul.ReservableResourceView,\n    dagnodeid::Base.UUID;\n    verbose\n)\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.deletereservationhook!-Tuple{MINDFul.AbstractSDNController, MINDFul.OXCView, Base.UUID}","page":"API","title":"MINDFul.deletereservationhook!","text":"deletereservationhook!(\n    sdn::MINDFul.AbstractSDNController,\n    oxcview::MINDFul.OXCView,\n    dagnodeid::Base.UUID;\n    verbose\n) -> Symbol\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.deletereservationhook!-Tuple{MINDFul.AbstractSDNController, MINDFul.ReservableResourceView, Base.UUID}","page":"API","title":"MINDFul.deletereservationhook!","text":"deletereservationhook!(\n    sdn::MINDFul.AbstractSDNController,\n    resourceview::MINDFul.ReservableResourceView,\n    dagnodeid::Base.UUID;\n    verbose\n) -> Symbol\n\n\nImplement this function to do custom actions per specific ReservableResourceView\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.edgeify-Tuple{Vector{Int64}}","page":"API","title":"MINDFul.edgeify","text":"edgeify(\n    path::Vector{Int64}\n) -> Vector{Graphs.SimpleGraphs.SimpleEdge{Int64}}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.emptyaggraphwithnewuuid-Union{Tuple{T}, Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID}, Base.UUID}} where T<:MINDFul.NodeView","page":"API","title":"MINDFul.emptyaggraphwithnewuuid","text":"emptyaggraphwithnewuuid(\n    ibnag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Array{T<:MINDFul.NodeView, 1}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID},\n    uuid::Base.UUID\n) -> AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.estimatecrossconnectionavailability-Tuple{MINDFul.IBNFramework, MINDFul.GlobalNode, MINDFul.GlobalNode}","page":"API","title":"MINDFul.estimatecrossconnectionavailability","text":"estimatecrossconnectionavailability(\n    ibnf::MINDFul.IBNFramework,\n    srcnode::MINDFul.GlobalNode,\n    dstnode::MINDFul.GlobalNode\n)\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.estimatecrossconnectionavailability-Tuple{MINDFul.IBNFramework{A, B, C, D, MINDFul.BestEmpiricalAvailabilityCompilation} where {A, B, C, D}, MINDFul.GlobalNode, MINDFul.GlobalNode}","page":"API","title":"MINDFul.estimatecrossconnectionavailability","text":"estimatecrossconnectionavailability(\n    ibnf::MINDFul.IBNFramework{A, B, C, D, MINDFul.BestEmpiricalAvailabilityCompilation} where {A, B, C, D},\n    srcglobalnode::MINDFul.GlobalNode,\n    dstglobalnode::MINDFul.GlobalNode\n)\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.estimateintraconnectionavailability-Tuple{MINDFul.IBNFramework, Int64, Int64}","page":"API","title":"MINDFul.estimateintraconnectionavailability","text":"estimateintraconnectionavailability(\n    ibnf::MINDFul.IBNFramework,\n    srcnode::Int64,\n    dstnode::Int64\n)\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.estimateintraconnectionavailability-Tuple{MINDFul.IBNFramework{A, B, C, D, MINDFul.BestEmpiricalAvailabilityCompilation} where {A, B, C, D}, Int64, Int64}","page":"API","title":"MINDFul.estimateintraconnectionavailability","text":"estimateintraconnectionavailability(\n    ibnf::MINDFul.IBNFramework{A, B, C, D, MINDFul.BestEmpiricalAvailabilityCompilation} where {A, B, C, D},\n    srclocalnode::Int64,\n    dstlocalnode::Int64\n)\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.findconsecutiveblocks-Union{Tuple{F}, Tuple{F, Vector}} where F<:Function","page":"API","title":"MINDFul.findconsecutiveblocks","text":"findconsecutiveblocks(\n    predicate::Function,\n    vec::Vector\n) -> Vector{Tuple{Int64, Int64}}\n\n\nReturn a Vector{Tuple{Int, Int}} with the consecutive blocks that satisfy function predicate. The first element of the tuple is the starting index and the second the last index of the block.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.firstfit-Tuple{AbstractVector{Bool}, Int64}","page":"API","title":"MINDFul.firstfit","text":"firstfit(\n    boolvec::AbstractVector{Bool},\n    lenghrequire::Int64\n) -> Union{Nothing, Int64}\n\n\nFinds first contiguous slot range of length lengthrequire that satisfies the boolvec. Return the starting index of the range or nothing if none available\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.generateRSAkeys-Tuple{String}","page":"API","title":"MINDFul.generateRSAkeys","text":"generateRSAkeys(configdir::String)\n\n\nFunction to generate RSA keys (only used for testing). In real scenarios, private keys must be previously generated and public keys must be shared accordingly.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.generateTLScertificate-Tuple{}","page":"API","title":"MINDFul.generateTLScertificate","text":"generateTLScertificate() -> Any\n\n\nFunction to generate a self-signed TLS certificate and corresponding private key.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.generatelightpathoxcadddropbypassspectrumlli-Tuple{Vector{Int64}, UnitRange{Int64}}","page":"API","title":"MINDFul.generatelightpathoxcadddropbypassspectrumlli","text":"generatelightpathoxcadddropbypassspectrumlli(\n    path::Vector{Int64},\n    spectrumslotsrange::UnitRange{Int64};\n    sourceadddropport,\n    opticalinitincomingnode,\n    destadddropport\n) -> Vector{MINDFul.OXCAddDropBypassSpectrumLLI}\n\n\nReturn a list of (@ref)[OXCAddDropBypassSpectrumLLI] that constitute a lightpath. According to the arguments a \"starting lightpath\", an \"ending lightpath\", or a \"lightpath segment\" can be created. The arguments are the following:\n\nsourceadddropport: nothing for a starting lightpath and an Integer denating the add/drop port otherwise\nopticalinitincomingnode : the (@ref)[LocalNode] denoting the incoming optical connection from the specified node for a starting lightpath. Set to nothing if not a starting lightpath\ndestadddropport: nothing for an ending lightpath and an Integer denating the add/drop port otherwise\n\nNote: not both sourceadddropport and opticalinitincomingnode can be nothing or have a values at the same time.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getafterlliidx-Tuple{MINDFul.IBNFramework, MINDFul.ConnectivityIntent, Any, MINDFul.OXCAddDropBypassSpectrumLLI}","page":"API","title":"MINDFul.getafterlliidx","text":"getafterlliidx(\n    ibnf::MINDFul.IBNFramework,\n    conintent::MINDFul.ConnectivityIntent,\n    llis,\n    oxclli::MINDFul.OXCAddDropBypassSpectrumLLI;\n    verbose\n) -> Any\n\n\nReturn all next logical low level intent indices from llis given that now signal is positioned in OXCAddDropBypassSpectrumLLI such that the conintent is satisfied. Return an empty vector if no logical next is found.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getafterlliidx-Tuple{MINDFul.IBNFramework, MINDFul.ConnectivityIntent, Any, MINDFul.RouterPortLLI}","page":"API","title":"MINDFul.getafterlliidx","text":"getafterlliidx(\n    ibnf::MINDFul.IBNFramework,\n    conintent::MINDFul.ConnectivityIntent,\n    llis,\n    rplli::MINDFul.RouterPortLLI;\n    verbose\n) -> Any\n\n\nReturn all next logical low level intent indices from llis given that now signal is positioned in RouterPortLLI such that the conintent is satisfied. Return an empty vector if no logical next is found.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getafterlliidx-Tuple{MINDFul.IBNFramework, MINDFul.ConnectivityIntent, Any, MINDFul.TransmissionModuleLLI}","page":"API","title":"MINDFul.getafterlliidx","text":"getafterlliidx(\n    ibnf::MINDFul.IBNFramework,\n    conintent::MINDFul.ConnectivityIntent,\n    llis,\n    tmlli::MINDFul.TransmissionModuleLLI;\n    verbose\n) -> Any\n\n\nReturn all next logical low level intent indices from llis given that now signal is positioned in TransmissionModuleLLI such that the conintent is satisfied. Return an empty vector if no logical next is found.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getavailabilityrequirement-Tuple{MINDFul.AvailabilityConstraint}","page":"API","title":"MINDFul.getavailabilityrequirement","text":"getavailabilityrequirement(\n    ac::MINDFul.AvailabilityConstraint\n) -> Float64\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getavailabilityrequirement-Tuple{MINDFul.MutableAvailabilityConstraint}","page":"API","title":"MINDFul.getavailabilityrequirement","text":"getavailabilityrequirement(\n    ac::MINDFul.MutableAvailabilityConstraint\n) -> Float64\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getavailabletransmissionmoduleviewindex-Tuple{MINDFul.NodeView}","page":"API","title":"MINDFul.getavailabletransmissionmoduleviewindex","text":"getavailabletransmissionmoduleviewindex(\n    nodeview::MINDFul.NodeView\n) -> Vector{Int64}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getbaseurl-Tuple{MINDFul.AbstractIBNFHandler}","page":"API","title":"MINDFul.getbaseurl","text":"getbaseurl(\n    remotehandler::MINDFul.AbstractIBNFHandler\n) -> Any\n\n\nGet the base URL of the HTTP server of a remote domain.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getcachedresults-Tuple{MINDFul.IntentCompilationAlgorithm}","page":"API","title":"MINDFul.getcachedresults","text":"getcachedresults(\n    intcompalg::MINDFul.IntentCompilationAlgorithm\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getcandidatepathsnum-Tuple{MINDFul.IntentCompilationAlgorithm}","page":"API","title":"MINDFul.getcandidatepathsnum","text":"getcandidatepathsnum(\n    intcompalg::MINDFul.IntentCompilationAlgorithm\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getcompliancetarget-Tuple{MINDFul.AvailabilityConstraint}","page":"API","title":"MINDFul.getcompliancetarget","text":"getcompliancetarget(\n    ac::MINDFul.AvailabilityConstraint\n) -> Float64\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getcompliancetarget-Tuple{MINDFul.MutableAvailabilityConstraint}","page":"API","title":"MINDFul.getcompliancetarget","text":"getcompliancetarget(\n    ac::MINDFul.MutableAvailabilityConstraint\n) -> Float64\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getcurrentlinkstate-Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView, Graphs.SimpleGraphs.SimpleEdge}","page":"API","title":"MINDFul.getcurrentlinkstate","text":"getcurrentlinkstate(\n    ibnag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView,\n    edge::Graphs.SimpleGraphs.SimpleEdge;\n    checkfirst,\n    verbose\n) -> Union{Nothing, Bool, Symbol}\n\n\nSame as getcurrentlinkstate(ibnf::IBNFramework) but doesn't send a request to other domains.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getcurrentlinkstate-Tuple{MINDFul.IBNFramework, Graphs.SimpleGraphs.SimpleEdge}","page":"API","title":"MINDFul.getcurrentlinkstate","text":"getcurrentlinkstate(\n    ibnf::MINDFul.IBNFramework,\n    edge::Graphs.SimpleGraphs.SimpleEdge;\n    checkfirst,\n    verbose\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getcurrentlinkstate-Tuple{MINDFul.OXCView, Graphs.SimpleGraphs.SimpleEdge}","page":"API","title":"MINDFul.getcurrentlinkstate","text":"getcurrentlinkstate(\n    oxcview::MINDFul.OXCView,\n    ed::Graphs.SimpleGraphs.SimpleEdge\n) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getdatetime-Tuple{MINDFul.BasicAlgorithmMemory}","page":"API","title":"MINDFul.getdatetime","text":"getdatetime(\n    intcompalg::MINDFul.BasicAlgorithmMemory\n) -> Dates.DateTime\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getdatetime-Tuple{MINDFul.IntentCompilationAlgorithm}","page":"API","title":"MINDFul.getdatetime","text":"getdatetime(\n    intcompalg::MINDFul.IntentCompilationAlgorithm\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getdatetime-Tuple{MINDFul.ReturnCodeTime}","page":"API","title":"MINDFul.getdatetime","text":"getdatetime(rct::MINDFul.ReturnCodeTime) -> Dates.DateTime\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getdatetime-Tuple{MINDFul.ReturnUUIDTime}","page":"API","title":"MINDFul.getdatetime","text":"getdatetime(rct::MINDFul.ReturnUUIDTime) -> Dates.DateTime\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getdestinationnodeallocations-Tuple{MINDFul.LightpathIntent}","page":"API","title":"MINDFul.getdestinationnodeallocations","text":"getdestinationnodeallocations(\n    lpintent::MINDFul.LightpathIntent\n) -> MINDFul.EndNodeAllocations\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getdictlinkempiricalavailabilities-Tuple{Any}","page":"API","title":"MINDFul.getdictlinkempiricalavailabilities","text":"getdictlinkempiricalavailabilities(\n    ibnf;\n    checkfirst,\n    verbose,\n    endtime\n) -> Dict\n\n\nReturn a dictionary with keys the edges and values the empirical availabilities.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getdictlinkupdowntimes-Tuple{Any}","page":"API","title":"MINDFul.getdictlinkupdowntimes","text":"getdictlinkupdowntimes(\n    ibnf;\n    checkfirst,\n    verbose,\n    endtime\n) -> Dict\n\n\nReturn a dictionary with keys the edges and values the up and downtimes.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getempiricalavailability-Tuple{MINDFul.IBNFramework, Vector{Int64}}","page":"API","title":"MINDFul.getempiricalavailability","text":"getempiricalavailability(\n    ibnf::MINDFul.IBNFramework,\n    path::Vector{Int64};\n    checkfirst,\n    verbose,\n    endtime\n) -> Any\n\n\nCalculate empirical availability of a path\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getempiricalavailability-Tuple{MINDFul.IBNFramework, Vector{Vector{Int64}}}","page":"API","title":"MINDFul.getempiricalavailability","text":"getempiricalavailability(\n    ibnf::MINDFul.IBNFramework,\n    ppath::Vector{Vector{Int64}};\n    checkfirst,\n    verbose,\n    endtime\n) -> Any\n\n\nCalculate empirical availability of a protected path\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getfirst-Tuple{Function, AbstractArray}","page":"API","title":"MINDFul.getfirst","text":"getfirst(predicate::Function, ar::AbstractArray) -> Any\n\n\nReturns the element is predicate is satisfied  or nothing otherwise.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getfirstavailableoxcadddropport-Tuple{MINDFul.NodeView}","page":"API","title":"MINDFul.getfirstavailableoxcadddropport","text":"getfirstavailableoxcadddropport(nodeview::MINDFul.NodeView)\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getfirstavailableoxcadddropport-Tuple{MINDFul.OXCView}","page":"API","title":"MINDFul.getfirstavailableoxcadddropport","text":"getfirstavailableoxcadddropport(oxcview::MINDFul.OXCView)\n\n\nReturn the first available oxc add/drop port and nothing if none found\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getfirstavailablerouterportindex-Tuple{MINDFul.NodeView}","page":"API","title":"MINDFul.getfirstavailablerouterportindex","text":"getfirstavailablerouterportindex(nodeview::MINDFul.NodeView)\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getfirstavailablerouterportindex-Tuple{MINDFul.RouterView}","page":"API","title":"MINDFul.getfirstavailablerouterportindex","text":"getfirstavailablerouterportindex(\n    routerview::MINDFul.RouterView\n)\n\n\nReturn the first available router port index and nothing if non available.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getfirstcompatibletransmoduleidxandmodeidx-Tuple{Vector{<:MINDFul.TransmissionModuleView}, Vector{Int64}, MINDFul.TransmissionModuleCompatibility}","page":"API","title":"MINDFul.getfirstcompatibletransmoduleidxandmodeidx","text":"getfirstcompatibletransmoduleidxandmodeidx(\n    transmissionmoduleviewpool::Vector{<:MINDFul.TransmissionModuleView},\n    availtransmdlidxs::Vector{Int64},\n    transmissionmodulecompat::MINDFul.TransmissionModuleCompatibility\n) -> Union{Nothing, Tuple{Int64, Int64}}\n\n\nReturn a integer tuple (Int, Int) denoting the first available and compatible transmission module index and its transmission mode index. If non found return nothing.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getfirsthalfavailabilityconstraint-Tuple{MINDFul.SplitGlobalNode}","page":"API","title":"MINDFul.getfirsthalfavailabilityconstraint","text":"getfirsthalfavailabilityconstraint(\n    splitglobalnode::MINDFul.SplitGlobalNode\n) -> Union{Nothing, MINDFul.AvailabilityConstraint}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getibnagweights-Tuple{MINDFul.CachedResults}","page":"API","title":"MINDFul.getibnagweights","text":"getibnagweights(\n    cr::MINDFul.CachedResults\n) -> Matrix{Unitful.Quantity{Float64, 𝐋, Unitful.FreeUnits{(km,), 𝐋, nothing}}}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getibnfcomm-Tuple{MINDFul.IBNFramework}","page":"API","title":"MINDFul.getibnfcomm","text":"getibnfcomm(\n    ibnf::MINDFul.IBNFramework\n) -> MINDFul.IBNFCommunication\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getibnfhandlergentoken-Tuple{MINDFul.AbstractIBNFHandler}","page":"API","title":"MINDFul.getibnfhandlergentoken","text":"getibnfhandlergentoken(\n    remotehandler::MINDFul.AbstractIBNFHandler\n) -> Any\n\n\nGet the generated token for authenticating a remote domain.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getibnfhandlerperm-Tuple{MINDFul.AbstractIBNFHandler}","page":"API","title":"MINDFul.getibnfhandlerperm","text":"getibnfhandlerperm(\n    remotehandler::MINDFul.AbstractIBNFHandler\n) -> Any\n\n\nGet the established permission of a remote domain.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getibnfhandlerport-Tuple{MINDFul.AbstractIBNFHandler}","page":"API","title":"MINDFul.getibnfhandlerport","text":"getibnfhandlerport(\n    remotehandler::MINDFul.AbstractIBNFHandler\n) -> Int64\n\n\nGet the port of the server of a remote domain.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getibnfhandlerrecvtoken-Tuple{MINDFul.AbstractIBNFHandler}","page":"API","title":"MINDFul.getibnfhandlerrecvtoken","text":"getibnfhandlerrecvtoken(\n    remotehandler::MINDFul.AbstractIBNFHandler\n) -> Any\n\n\nGet the received token for authenticating to a remote domain.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getibnfhandlerrsapublickey-Tuple{MINDFul.RemoteHTTPHandler}","page":"API","title":"MINDFul.getibnfhandlerrsapublickey","text":"getibnfhandlerrsapublickey(\n    remotehandler::MINDFul.RemoteHTTPHandler\n) -> String\n\n\nGet the RSA public key of a remote domain.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getibnfhandlerrsasecret-Tuple{MINDFul.RemoteHTTPHandler}","page":"API","title":"MINDFul.getibnfhandlerrsasecret","text":"getibnfhandlerrsasecret(\n    remotehandler::MINDFul.RemoteHTTPHandler\n) -> String\n\n\nGet the RSA secret for authenticating a remote domain.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getibnfrsaprivatekey-Tuple{MINDFul.IBNFramework}","page":"API","title":"MINDFul.getibnfrsaprivatekey","text":"getibnfrsaprivatekey(ibnf::MINDFul.IBNFramework) -> Any\n\n\nGet the RSA private key of a local domain.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getibnfserver-Tuple{MINDFul.IBNFramework}","page":"API","title":"MINDFul.getibnfserver","text":"getibnfserver(\n    ibnf::MINDFul.IBNFramework\n) -> Union{Nothing, HTTP.Servers.Server{HTTP.Servers.Listener{Nothing, Sockets.TCPServer}}, HTTP.Servers.Server{HTTP.Servers.Listener{MbedTLS.SSLConfig, Sockets.TCPServer}}}\n\n\nGet the server of an IBNFramework.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getibnfwithid-Tuple{Vector{<:MINDFul.IBNFramework}, Base.UUID}","page":"API","title":"MINDFul.getibnfwithid","text":"getibnfwithid(\n    ibnfs::Vector{<:MINDFul.IBNFramework},\n    ibnfid::Base.UUID\n) -> Union{Nothing, MINDFul.IBNFramework}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getidaginfo-Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo}}","page":"API","title":"MINDFul.getidaginfo","text":"getidaginfo(\n    intentdag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo}\n) -> MINDFul.IntentDAGInfo\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getidagnextuuidcounter-Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo}}","page":"API","title":"MINDFul.getidagnextuuidcounter","text":"getidagnextuuidcounter(\n    intentdag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo}\n) -> Base.UUID\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getidagnode-Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo}, Base.UUID}","page":"API","title":"MINDFul.getidagnode","text":"getidagnode(\n    intentdag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo},\n    dagnodeid::Base.UUID\n) -> MINDFul.IntentDAGNode\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getidagnodechildren-Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo}, Base.UUID}","page":"API","title":"MINDFul.getidagnodechildren","text":"getidagnodechildren(\n    idag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo},\n    idagnodeid::Base.UUID\n) -> Vector{MINDFul.IntentDAGNode}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getidagnodechildren-Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo}, MINDFul.IntentDAGNode}","page":"API","title":"MINDFul.getidagnodechildren","text":"getidagnodechildren(\n    idag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo},\n    idagnode::MINDFul.IntentDAGNode\n) -> Vector{MINDFul.IntentDAGNode}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getidagnodedescendants-Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo}, Base.UUID}","page":"API","title":"MINDFul.getidagnodedescendants","text":"getidagnodedescendants(\n    idag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo},\n    idagnodeid::Base.UUID;\n    exclusive,\n    includeroot,\n    parentsfirst\n) -> Vector{MINDFul.IntentDAGNode}\n\n\nGet all descendants of DAG dag starting from node idagnodeid Set exclusive=true  to get nodes that have idagnodeid as the only ancestor Set parentsfirst=true to get the upper level children first and false to get the leafs first.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getidagnodeidx-Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo}, Base.UUID}","page":"API","title":"MINDFul.getidagnodeidx","text":"getidagnodeidx(\n    intentdag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo},\n    dagnodeid::Base.UUID\n) -> Int64\n\n\nGet the vertex index of the intent DAG node with id dagnodeid. Errors if UUID doesn't exist. It's slow: maybe keep a dict/table ?\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getidagnodeidxsconnected-Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo}, Base.UUID}","page":"API","title":"MINDFul.getidagnodeidxsconnected","text":"getidagnodeidxsconnected(\n    idag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo},\n    idagnodeid::Base.UUID\n) -> Vector{Int64}\n\n\nGet all connected nodes of DAG dag starting from node idagnodeid. Return as node indices of the graph.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getidagnodeidxsdescendants-Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo}, Base.UUID}","page":"API","title":"MINDFul.getidagnodeidxsdescendants","text":"getidagnodeidxsdescendants(\n    idag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo},\n    idagnodeid::Base.UUID;\n    exclusive,\n    includeroot\n) -> Vector{Int64}\n\n\nGet all descendants of DAG dag starting from node idagnodeid. Return as node indices of the graph. Set exclusive=true  to get nodes that have idagnodeid as the only ancestor\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getidagnodeleafs-Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo}, Base.UUID}","page":"API","title":"MINDFul.getidagnodeleafs","text":"getidagnodeleafs(\n    idag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo},\n    idagnodeid::Base.UUID;\n    exclusive,\n    chooseprotected,\n    autoinstall\n) -> Vector{MINDFul.IntentDAGNode}\n\n\nGet the leafs of DAG dag starting from node idn. Set exclusive=true to get nodes that have idn as the only ancestor With chooseprotected::Int you can choose which protected path to select. Default is 1. With 0 you choose all. If an intent contains more than one ProtectedLightpathIntent there is no way to choose exactly. Pass autoinstall:Bool = true to ignore failed regions of the intent DAG and auto-choose protection path. It will choose the available path from 1 to n. chooseprotected must still be non-zero.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getidagnodeleafs2install-Tuple{MINDFul.IBNFramework, Base.UUID}","page":"API","title":"MINDFul.getidagnodeleafs2install","text":"getidagnodeleafs2install(\n    ibnf::MINDFul.IBNFramework,\n    idagnodeid::Base.UUID\n) -> Vector{MINDFul.IntentDAGNode}\n\n\nReturn the leaf idagnodes to install. Code is very similar to getidagnodeleafs(::IntentDAG) but suited for exactly the isntallation scenario If installation is not possible return empty.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getidagnodellis-Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo}, Base.UUID}","page":"API","title":"MINDFul.getidagnodellis","text":"getidagnodellis(\n    idag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo},\n    idagnodeid::Base.UUID;\n    exclusive\n) -> Vector{MINDFul.IntentDAGNode}\n\n\nGet all the Low Level Intents that are leafs of idagnodeid Set exclusive=true to get nodes that have idn as the only ancestor\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getidagnodellis-Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo}}","page":"API","title":"MINDFul.getidagnodellis","text":"getidagnodellis(\n    idag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo}\n) -> Vector{MINDFul.IntentDAGNode}\n\n\nGet all the Low Level Intents that exist on the DAG\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getidagnodeparents-Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo}, Base.UUID}","page":"API","title":"MINDFul.getidagnodeparents","text":"getidagnodeparents(\n    idag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo},\n    idagnodeid::Base.UUID\n) -> Vector{MINDFul.IntentDAGNode}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getidagnodeparents-Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo}, MINDFul.IntentDAGNode}","page":"API","title":"MINDFul.getidagnodeparents","text":"getidagnodeparents(\n    idag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo},\n    idagnode::MINDFul.IntentDAGNode\n) -> Vector{MINDFul.IntentDAGNode}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getidagnoderoots-Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo}, Base.UUID}","page":"API","title":"MINDFul.getidagnoderoots","text":"getidagnoderoots(\n    idag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo},\n    idagnodeid::Base.UUID\n) -> Vector{MINDFul.IntentDAGNode}\n\n\nGet the roots of DAG dag starting from node idn.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getidagnodes-Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo}}","page":"API","title":"MINDFul.getidagnodes","text":"getidagnodes(\n    intentdag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo}\n) -> Vector{MINDFul.IntentDAGNode}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getinstalledlightpaths-Tuple{MINDFul.IntentDAGInfo}","page":"API","title":"MINDFul.getinstalledlightpaths","text":"getinstalledlightpaths(\n    intentdaginfo::MINDFul.IntentDAGInfo\n) -> Dict{Base.UUID, MINDFul.LightpathRepresentation}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getintcompalg-Tuple{MINDFul.IBNFramework}","page":"API","title":"MINDFul.getintcompalg","text":"getintcompalg(\n    s::MINDFul.IBNFramework\n) -> MINDFul.IntentCompilationAlgorithm\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getintentissuer-Tuple{MINDFul.IntentDAGNode}","page":"API","title":"MINDFul.getintentissuer","text":"getintentissuer(\n    idagnode::MINDFul.IntentDAGNode\n) -> MINDFul.IntentIssuer\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getlightpathconnectivityintent-Tuple{MINDFul.CrossLightpathIntent}","page":"API","title":"MINDFul.getlightpathconnectivityintent","text":"getlightpathconnectivityintent(\n    clpi::MINDFul.CrossLightpathIntent\n) -> MINDFul.ConnectivityIntent\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getlinkstates-Tuple{MINDFul.IBNFramework, Graphs.SimpleGraphs.SimpleEdge}","page":"API","title":"MINDFul.getlinkstates","text":"getlinkstates(\n    ibnf::MINDFul.IBNFramework,\n    edge::Graphs.SimpleGraphs.SimpleEdge;\n    checkfirst,\n    verbose\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getlinkstates-Tuple{MINDFul.OXCView, Graphs.SimpleGraphs.SimpleEdge}","page":"API","title":"MINDFul.getlinkstates","text":"getlinkstates(\n    oxcview::MINDFul.OXCView,\n    ed::Graphs.SimpleGraphs.SimpleEdge\n) -> Vector{Tuple{Dates.DateTime, Bool}}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getlinkstates-Tuple{MINDFul.OXCView}","page":"API","title":"MINDFul.getlinkstates","text":"getlinkstates(\n    oxcview::MINDFul.OXCView\n) -> Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, Vector{Tuple{Dates.DateTime, Bool}}}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getlinkupdowntimes-Tuple{Any, Any}","page":"API","title":"MINDFul.getlinkupdowntimes","text":"getlinkupdowntimes(\n    ibnf,\n    edge;\n    checkfirst,\n    verbose,\n    endtime\n) -> MINDFul.UpDownTimes\n\n\nReturn the up and downtimes for the specific link\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getlocalnodenum-Tuple{MINDFul.IBNFramework}","page":"API","title":"MINDFul.getlocalnodenum","text":"getlocalnodenum(ibnf::MINDFul.IBNFramework) -> Any\n\n\nReturn the number of local nodes, i.e. not border nodes.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getloginterupdowntimes-Tuple{MINDFul.BasicAlgorithmMemory}","page":"API","title":"MINDFul.getloginterupdowntimes","text":"getloginterupdowntimes(\n    bam::MINDFul.BasicAlgorithmMemory\n) -> Dict{MINDFul.GlobalEdge, Dict{Base.UUID, MINDFul.UpDownTimesNDatetime}}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getloginterupdowntimes-Tuple{MINDFul.IntentCompilationAlgorithmWithMemory}","page":"API","title":"MINDFul.getloginterupdowntimes","text":"getloginterupdowntimes(\n    intentcomp::MINDFul.IntentCompilationAlgorithmWithMemory\n) -> Dict{MINDFul.GlobalEdge, Dict{Base.UUID, MINDFul.UpDownTimesNDatetime}}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getlogintrapaths-Tuple{MINDFul.BasicAlgorithmMemory}","page":"API","title":"MINDFul.getlogintrapaths","text":"getlogintrapaths(\n    bam::MINDFul.BasicAlgorithmMemory\n) -> Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, Dict{Vector{Vector{Int64}}, Int64}}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getlogintrapaths-Tuple{MINDFul.IntentCompilationAlgorithmWithMemory}","page":"API","title":"MINDFul.getlogintrapaths","text":"getlogintrapaths(\n    intentcomp::MINDFul.IntentCompilationAlgorithmWithMemory\n) -> Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, Dict{Vector{Vector{Int64}}, Int64}}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getlogtupletstate-Tuple{Tuple{Dates.DateTime, Enum{Int32}}}","page":"API","title":"MINDFul.getlogtupletstate","text":"getlogtupletstate(\n    intentlogstatetuple::Tuple{Dates.DateTime, Enum{Int32}}\n) -> Enum{Int32}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getlogtuplettime-Tuple{Tuple{Dates.DateTime, Enum{Int32}}}","page":"API","title":"MINDFul.getlogtuplettime","text":"getlogtuplettime(\n    intentlogstatetuple::Tuple{Dates.DateTime, Enum{Int32}}\n) -> Dates.DateTime\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getlowestratetransmissionmode-Tuple{MINDFul.TransmissionModuleView, Unitful.Quantity{Float64, Data 𝐓^-1, Unitful.FreeUnits{(Gbps,), Data 𝐓^-1, nothing}}, Unitful.Quantity{Float64, 𝐋, Unitful.FreeUnits{(km,), 𝐋, nothing}}}","page":"API","title":"MINDFul.getlowestratetransmissionmode","text":"getlowestratetransmissionmode(\n    transmissionmoduleview::MINDFul.TransmissionModuleView,\n    demandrate::Unitful.Quantity{Float64, Data 𝐓^-1, Unitful.FreeUnits{(Gbps,), Data 𝐓^-1, nothing}},\n    demanddistance::Unitful.Quantity{Float64, 𝐋, Unitful.FreeUnits{(km,), 𝐋, nothing}}\n) -> Union{Nothing, Int64}\n\n\nReturn the index with the lowest GBPS rate that can get deployed for the given demand rate and distance. If non is find return nothing.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getname-Tuple{Any}","page":"API","title":"MINDFul.getname","text":"getname(s) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getnetworkoperatoridagnodes-Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo}}","page":"API","title":"MINDFul.getnetworkoperatoridagnodes","text":"getnetworkoperatoridagnodes(\n    idag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo}\n) -> Vector{MINDFul.IntentDAGNode}\n\n\nRequest topology information\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getnodeindex-Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView, MINDFul.GlobalNode}","page":"API","title":"MINDFul.getnodeindex","text":"getnodeindex(\n    ibnag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView,\n    globalnode::MINDFul.GlobalNode\n) -> Union{Nothing, Int64}\n\n\nReturn the index given the global representation. Return nothing if not found\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getoxclliedges-Tuple{MINDFul.OXCAddDropBypassSpectrumLLI}","page":"API","title":"MINDFul.getoxclliedges","text":"getoxclliedges(\n    oxclli::MINDFul.OXCAddDropBypassSpectrumLLI\n) -> Vector{Graphs.SimpleGraphs.SimpleEdge{Int64}}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getpath-Tuple{MINDFul.LightpathIntent}","page":"API","title":"MINDFul.getpath","text":"getpath(lpintent::MINDFul.LightpathIntent) -> Vector{Int64}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getpath-Tuple{MINDFul.LightpathRepresentation}","page":"API","title":"MINDFul.getpath","text":"getpath(\n    lpr::MINDFul.LightpathRepresentation\n) -> Vector{Vector{Int64}}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getpathdistance-Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView, Vector{Int64}}","page":"API","title":"MINDFul.getpathdistance","text":"getpathdistance(\n    ibnag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView,\n    path::Vector{Int64}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getpathdistance-Tuple{Matrix, Vector{Int64}}","page":"API","title":"MINDFul.getpathdistance","text":"getpathdistance(ws::Matrix, path::Vector{Int64}) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getpathdistance2-Tuple{Matrix, Vector{Int64}}","page":"API","title":"MINDFul.getpathdistance2","text":"getpathdistance2(ws::Matrix, path::Vector{Int64}) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getpathdistance3-Tuple{Matrix, Vector{Int64}}","page":"API","title":"MINDFul.getpathdistance3","text":"getpathdistance3(ws::Matrix, path::Vector{Int64}) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getpathsforprotectionnum-Tuple{MINDFul.IntentCompilationAlgorithm}","page":"API","title":"MINDFul.getpathsforprotectionnum","text":"getpathsforprotectionnum(\n    intcompalg::MINDFul.IntentCompilationAlgorithm\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getprdestinationnodeallocations-Tuple{MINDFul.ProtectedLightpathIntent}","page":"API","title":"MINDFul.getprdestinationnodeallocations","text":"getprdestinationnodeallocations(\n    prlpintent::MINDFul.ProtectedLightpathIntent\n) -> Vector{MINDFul.EndNodeAllocations}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getprpath-Tuple{MINDFul.ProtectedLightpathIntent}","page":"API","title":"MINDFul.getprpath","text":"getprpath(\n    prlpintent::MINDFul.ProtectedLightpathIntent\n) -> Vector{Vector{Int64}}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getprsourcenodeallocations-Tuple{MINDFul.ProtectedLightpathIntent}","page":"API","title":"MINDFul.getprsourcenodeallocations","text":"getprsourcenodeallocations(\n    prlpintent::MINDFul.ProtectedLightpathIntent\n) -> Vector{MINDFul.EndNodeAllocations}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getprspectrumslotsrange-Tuple{MINDFul.ProtectedLightpathIntent}","page":"API","title":"MINDFul.getprspectrumslotsrange","text":"getprspectrumslotsrange(\n    prlpintent::MINDFul.ProtectedLightpathIntent\n) -> Vector{UnitRange{Int64}}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getremoteconnectivityintent-Tuple{MINDFul.CrossLightpathIntent}","page":"API","title":"MINDFul.getremoteconnectivityintent","text":"getremoteconnectivityintent(\n    clpi::MINDFul.CrossLightpathIntent\n) -> MINDFul.ConnectivityIntent\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getresidualbandwidth-Tuple{MINDFul.IBNFramework, Base.UUID, Unitful.Quantity{Float64, Data 𝐓^-1, Unitful.FreeUnits{(Gbps,), Data 𝐓^-1, nothing}}}","page":"API","title":"MINDFul.getresidualbandwidth","text":"getresidualbandwidth(\n    ibnf::MINDFul.IBNFramework,\n    lightpathuuid::Base.UUID,\n    residualbandwidth::Unitful.Quantity{Float64, Data 𝐓^-1, Unitful.FreeUnits{(Gbps,), Data 𝐓^-1, nothing}};\n    onlyinstalled\n) -> Unitful.Quantity{Float64, Data 𝐓^-1, Unitful.FreeUnits{(Gbps,), Data 𝐓^-1, nothing}}\n\n\nReturn how much bandwidth is left unused in the lightpath\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getresidualbandwidth-Tuple{MINDFul.IBNFramework, Base.UUID}","page":"API","title":"MINDFul.getresidualbandwidth","text":"getresidualbandwidth(\n    ibnf::MINDFul.IBNFramework,\n    intentuuid::Base.UUID;\n    onlyinstalled\n) -> Unitful.Quantity{Float64, Data 𝐓^-1, Unitful.FreeUnits{(Gbps,), Data 𝐓^-1, nothing}}\n\n\nReturn 0 GBPS if invalid intent\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getreturncode-Tuple{MINDFul.ReturnCodeTime}","page":"API","title":"MINDFul.getreturncode","text":"getreturncode(rct::MINDFul.ReturnCodeTime) -> Symbol\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getrouterlli-Tuple{MINDFul.EndNodeAllocations}","page":"API","title":"MINDFul.getrouterlli","text":"getrouterlli(\n    ena::MINDFul.EndNodeAllocations\n) -> MINDFul.RouterPortLLI\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getrouterport-Tuple{MINDFul.IBNFramework, MINDFul.RouterPortLLI}","page":"API","title":"MINDFul.getrouterport","text":"getrouterport(\n    ibnf::MINDFul.IBNFramework,\n    intent::MINDFul.RouterPortLLI\n) -> MINDFul.RouterPort\n\n\nGet the router port\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getrouterport-Tuple{MINDFul.RouterView, Any}","page":"API","title":"MINDFul.getrouterport","text":"getrouterport(s::MINDFul.RouterView, idx) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getrouterportrate-Tuple{MINDFul.IBNFramework, MINDFul.RouterPortLLI}","page":"API","title":"MINDFul.getrouterportrate","text":"getrouterportrate(\n    ibnf::MINDFul.IBNFramework,\n    intent::MINDFul.RouterPortLLI\n) -> Unitful.Quantity{Float64, Data 𝐓^-1, Unitful.FreeUnits{(Gbps,), Data 𝐓^-1, nothing}}\n\n\nGet the router port\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getrouterportrate-Tuple{MINDFul.TransmissionModuleCompatibility}","page":"API","title":"MINDFul.getrouterportrate","text":"getrouterportrate(\n    tmc::MINDFul.TransmissionModuleCompatibility\n) -> Union{Nothing, Unitful.Quantity{Float64, Data 𝐓^-1, Unitful.FreeUnits{(Gbps,), Data 𝐓^-1, nothing}}}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getrouterports-Tuple{MINDFul.RouterView}","page":"API","title":"MINDFul.getrouterports","text":"getrouterports(\n    s::MINDFul.RouterView\n) -> Vector{MINDFul.RouterPort}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getsecondhalfavailabilityconstraint-Tuple{MINDFul.SplitGlobalNode}","page":"API","title":"MINDFul.getsecondhalfavailabilityconstraint","text":"getsecondhalfavailabilityconstraint(\n    splitglobalnode::MINDFul.SplitGlobalNode\n) -> Union{Nothing, MINDFul.AvailabilityConstraint}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getsourcenodeallocations-Tuple{MINDFul.LightpathIntent}","page":"API","title":"MINDFul.getsourcenodeallocations","text":"getsourcenodeallocations(\n    lpintent::MINDFul.LightpathIntent\n) -> MINDFul.EndNodeAllocations\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getstaged-Tuple{MINDFul.NodeView}","page":"API","title":"MINDFul.getstaged","text":"getstaged(\n    nodeview::MINDFul.NodeView\n) -> Union{Nothing, Set{MINDFul.TransmissionModuleLLI}}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getstaged-Tuple{MINDFul.OXCView}","page":"API","title":"MINDFul.getstaged","text":"getstaged(\n    oxcview::MINDFul.OXCView\n) -> Set{MINDFul.OXCAddDropBypassSpectrumLLI}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getstaged-Tuple{MINDFul.RouterView}","page":"API","title":"MINDFul.getstaged","text":"getstaged(\n    routerview::MINDFul.RouterView\n) -> Set{MINDFul.RouterPortLLI}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getstartsoptically-Tuple{MINDFul.LightpathRepresentation}","page":"API","title":"MINDFul.getstartsoptically","text":"getstartsoptically(\n    lpr::MINDFul.LightpathRepresentation\n) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getterminatessoptically-Tuple{MINDFul.LightpathRepresentation}","page":"API","title":"MINDFul.getterminatessoptically","text":"getterminatessoptically(\n    lpr::MINDFul.LightpathRepresentation\n) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.gettotalbandwidth-Tuple{MINDFul.LightpathRepresentation}","page":"API","title":"MINDFul.gettotalbandwidth","text":"gettotalbandwidth(\n    lpr::MINDFul.LightpathRepresentation\n) -> Unitful.Quantity{Float64, Data 𝐓^-1, Unitful.FreeUnits{(Gbps,), Data 𝐓^-1, nothing}}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.gettrasmissionmodulelli-Tuple{MINDFul.EndNodeAllocations}","page":"API","title":"MINDFul.gettrasmissionmodulelli","text":"gettrasmissionmodulelli(\n    ena::MINDFul.EndNodeAllocations\n) -> MINDFul.TransmissionModuleLLI\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getupdowntimes!-Union{Tuple{T}, Tuple{R}, Tuple{MINDFul.UpDownTimesNDatetime, Array{Tuple{R, T}, 1}}, Tuple{MINDFul.UpDownTimesNDatetime, Array{Tuple{R, T}, 1}, Any}} where {R, T}","page":"API","title":"MINDFul.getupdowntimes!","text":"getupdowntimes!(\n    updowntimesndatetime::MINDFul.UpDownTimesNDatetime,\n    ls::Array{Tuple{R, T}, 1}\n) -> MINDFul.UpDownTimesNDatetime\ngetupdowntimes!(\n    updowntimesndatetime::MINDFul.UpDownTimesNDatetime,\n    ls::Array{Tuple{R, T}, 1},\n    endtime\n) -> MINDFul.UpDownTimesNDatetime\n\n\nIncremeantaly update updowntimesndatetime given the new ls\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getupdowntimes-Union{Tuple{Array{Tuple{R, T}, 1}}, Tuple{T}, Tuple{R}, Tuple{Array{Tuple{R, T}, 1}, Any}} where {R, T}","page":"API","title":"MINDFul.getupdowntimes","text":"getupdowntimes(\n    ls::Array{Tuple{R, T}, 1}\n) -> MINDFul.UpDownTimes\ngetupdowntimes(\n    ls::Array{Tuple{R, T}, 1},\n    endtime\n) -> MINDFul.UpDownTimes\n\n\nGet uptime and downtime periods from link states. Return a tuple with the first element being the uptimes in Milliseconds and the second the downtimes in Milliseconds. If endtime is different that the one in list, pass it.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getuuid-Tuple{MINDFul.ReturnUUIDTime}","page":"API","title":"MINDFul.getuuid","text":"getuuid(rct::MINDFul.ReturnUUIDTime) -> Base.UUID\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getyenpathsdict-Tuple{MINDFul.CachedResults}","page":"API","title":"MINDFul.getyenpathsdict","text":"getyenpathsdict(\n    cr::MINDFul.CachedResults\n) -> Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, Vector{Vector{Int64}}}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getyenpathsdistsdict-Tuple{MINDFul.CachedResults}","page":"API","title":"MINDFul.getyenpathsdistsdict","text":"getyenpathsdistsdict(\n    cr::MINDFul.CachedResults\n) -> Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, Vector{Unitful.Quantity{Float64, 𝐋, Unitful.FreeUnits{(km,), 𝐋, nothing}}}}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.groomifllichildexists!-Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo}, MINDFul.IntentDAGNode, MINDFul.IntentDAGNode, MINDFul.LowLevelIntent}","page":"API","title":"MINDFul.groomifllichildexists!","text":"groomifllichildexists!(\n    idag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo},\n    idagnodegrandpa::MINDFul.IntentDAGNode,\n    idagnodeparent::MINDFul.IntentDAGNode,\n    lli::MINDFul.LowLevelIntent\n) -> Bool\n\n\nGroom (i.e. connect outgoing edge to the LLI) if it exists already as a child to idagnode Return true if it happens and false otherwise\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.handshake_init!-Tuple{MINDFul.IBNFramework, MINDFul.RemoteHTTPHandler, String}","page":"API","title":"MINDFul.handshake_init!","text":"handshake_init!(\n    ibnf::MINDFul.IBNFramework,\n    remoteibnfhandler::MINDFul.RemoteHTTPHandler,\n    encryptedsecret::String\n) -> Any\n\n\nExchange of the handshake information with the remote IBN framework. Both domains will generate a token to their peer that must be attached in the subsequent requests for authentication. Each domain has previously set a permission level for each of its neighbours. The available functions of the remote IBN framework will also be sent for information.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.hasidagnodechildren-Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo}, Base.UUID}","page":"API","title":"MINDFul.hasidagnodechildren","text":"hasidagnodechildren(\n    idag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo},\n    idagnodeid::Base.UUID\n) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.hasidagnodechildren-Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo}, MINDFul.IntentDAGNode}","page":"API","title":"MINDFul.hasidagnodechildren","text":"hasidagnodechildren(\n    idag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo},\n    idagnode::MINDFul.IntentDAGNode\n) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.hasidagnodeparents-Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo}, Base.UUID}","page":"API","title":"MINDFul.hasidagnodeparents","text":"hasidagnodeparents(\n    idag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo},\n    idagnodeid::Base.UUID\n) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.hasidagnodeparents-Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo}, MINDFul.IntentDAGNode}","page":"API","title":"MINDFul.hasidagnodeparents","text":"hasidagnodeparents(\n    idag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo},\n    idagnode::MINDFul.IntentDAGNode\n) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.increaseidagcounter!-Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo}}","page":"API","title":"MINDFul.increaseidagcounter!","text":"increaseidagcounter!(\n    intentdag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo}\n) -> Int64\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.insertreservation!-Tuple{MINDFul.AbstractSDNController, MINDFul.ReservableResourceView, Base.UUID, Any}","page":"API","title":"MINDFul.insertreservation!","text":"insertreservation!(\n    sdn::MINDFul.AbstractSDNController,\n    resourceview::MINDFul.ReservableResourceView,\n    dagnodeid::Base.UUID,\n    reservationdescription;\n    verbose\n) -> Symbol\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.insertreservationhook!-Tuple{MINDFul.AbstractSDNController, MINDFul.OXCView, Base.UUID, MINDFul.OXCAddDropBypassSpectrumLLI}","page":"API","title":"MINDFul.insertreservationhook!","text":"insertreservationhook!(\n    sdn::MINDFul.AbstractSDNController,\n    oxcview::MINDFul.OXCView,\n    dagnodeid::Base.UUID,\n    reservationdescription::MINDFul.OXCAddDropBypassSpectrumLLI;\n    verbose\n) -> Symbol\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.insertreservationhook!-Tuple{MINDFul.AbstractSDNController, MINDFul.ReservableResourceView, Base.UUID, Any}","page":"API","title":"MINDFul.insertreservationhook!","text":"insertreservationhook!(\n    sdn::MINDFul.AbstractSDNController,\n    resourceview::MINDFul.ReservableResourceView,\n    dagnodeid::Base.UUID,\n    reservationdescription;\n    verbose\n) -> Symbol\n\n\nImplement this function to do custom actions per specific ReservableResourceView\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.intradomaincompilationtemplate-Tuple{}","page":"API","title":"MINDFul.intradomaincompilationtemplate","text":"intradomaincompilationtemplate(\n;\n    prioritizepaths,\n    prioritizegrooming,\n    prioritizerouterport,\n    prioritizetransmdlandmode,\n    choosespectrum,\n    chooseoxcadddropport,\n    offsettime\n) -> MINDFul.var\"#328#336\"{MINDFul.var\"#328#329#337\"{typeof(MINDFul.prioritizepaths_shortest), typeof(MINDFul.prioritizegrooming_default), typeof(MINDFul.prioritizerouterports_lowestrate), typeof(MINDFul.prioritizetransmdlmode_cheaplowrate), typeof(MINDFul.choosespectrum_firstfit), typeof(MINDFul.chooseoxcadddropport_first)}}\n\n\nAIntra domain compilation algorithm template. Return function to do the intra domain compilation with the signature\n\nintradomainalgfun(\n    ibnf::IBNFramework, \n    idagnode::IntentDAGNode{<:ConnectivityIntent},\n) -> Symbol\n\nThe returned algorithm can be customized as follows.\n\nThe major selection process is made on the source.\n\nInterfaces needed:\n\ngetcandidatepathsnum(\n    intentcompilationalgorithm::IntentCompilationAlgorithm)\n -> Int\n\nReturn the candidate paths with highest priority first as Vector{Vector{Int}}}. Return empty collection if non available. TODO docts protection: Protection paths... shouldnt end on border node !\n\nprioritizepaths(\n    ibnf::IBNFramework,\n    idagnode::IntentDAGNode{<:ConnectivityIntent},\n) -> Vector{Vector{LocalNode}}\n\nReturn a Vector of grooming possibilities. Return a Vector of grooming possibilities: Vector{Vector{Union{UUID, Edge{Int}}}} Each element is a Vector of either an intent UUID or a new connectivity intent defined with Edge.\n\nprioritizegrooming(\n    ibnf::IBNFramework, \n    idagnode::IntentDAGNode{<:ConnectivityIntent}, \n\nReturn the candidate router ports with highest priority first Return empty collection if non available.\n\nprioritizerouterport(\n    ibnf::IBNFramework,\n    idagnode::IntentDAGNode{<:ConnectivityIntent},\n    node::LocalNode\n) -> Vector{Int}\n\nReturn the transmission module index and the transmission mode index of that module as a Vector{Tuple{Int, Int}} with the first being the transmission module index and the second the transmission mode. If this is calculated for the source node (default) pass path::Vector{LocalNode} and transmdlcompat::Nothing. If this is calculated for the destination node pass path::Nothing and transmdlcompat::TransmissionModuleCompatibility Return empty collection if non available.\n\nprioritizetransmdlandmode(\n    ibnf::IBNFramework,\n    idagnode::IntentDAGNode{<:ConnectivityIntent},\n    node::LocalNode,\n    path::Union{Nothing, Vector{LocalNode}},\n    transmdlcompat::Union{Nothing, TransmissionModuleCompatibility}=nothing\n) -> Vector{Tuple{Int, Int}}\n\nReturn the first index of the spectrum slot range to be allocated. If none found, return nothing\n\nchoosespectrum(\n    ibnf::IBNFramework,\n    idagnode::IntentDAGNode{<:ConnectivityIntent},\n    path::Vector{LocalNode},\n    demandslotsneeded::Int\n) -> Vector{Int}\n\nReturn the index of the add/drop OXC port to allocate at node node If none found, return nothing\n\nchooseoxcadddropport(\n    ibnf::IBNFramework,\n    idagnode::IntentDAGNode{<:ConnectivityIntent},\n    node::LocalNode\n) -> Vector{Int}\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.intradomaincompilationtemplate_destination!-Union{Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{MINDFul.IBNFramework, MINDFul.IntentDAGNode{<:MINDFul.ConnectivityIntent}, Any, Int64, UnitRange{Int64}, F1, F2, F3, MINDFul.MutableEndNodeAllocations}} where {F1<:Function, F2<:Function, F3<:Function}","page":"API","title":"MINDFul.intradomaincompilationtemplate_destination!","text":"intradomaincompilationtemplate_destination!(\n    ibnf::MINDFul.IBNFramework,\n    idagnode::MINDFul.IntentDAGNode{<:MINDFul.ConnectivityIntent},\n    transmissionmodulecompat,\n    opticalincomingnode::Int64,\n    spectrumslotsrange::UnitRange{Int64},\n    prioritizerouterport::Function,\n    prioritizetransmdlmode::Function,\n    chooseoxcadddropport::Function,\n    mena::MINDFul.MutableEndNodeAllocations;\n    verbose,\n    offsettime\n) -> Symbol\n\n\nTakes care of the final node (destination). Return the returncode of the procedure. Also mutate lowlevelintentstoadd to add the low-level intents found.\n\nThe following functions must be passed in (entry point from intradomaincompilationtemplate)\n\nReturn the candidate router ports with highest priority first Return empty collection if non available.\n\nprioritizerouterport(\n    ibnf::IBNFramework,\n    idagnode::IntentDAGNode{<:ConnectivityIntent},\n    node::LocalNode\n) -> Vector{Int}\n\nReturn the transmission module index and the transmission mode index of that module as a Vector{Tuple{Int, Int}} with the first being the transmission module index and the second the transmission mode. If this is calculated for the source node (default) pass path::Vector{LocalNode} and transmdlcompat::Nothing. If this is calculated for the destination node pass path::Nothing and transmdlcompat::TransmissionModuleCompatibility Return empty collection if non available.\n\nprioritizetransmdlandmode(\n    ibnf::IBNFramework,\n    idagnode::IntentDAGNode{<:ConnectivityIntent},\n    node::LocalNode,\n    path::Union{Nothing, Vector{LocalNode}},\n    routerportrate::GBPSf,\n    transmdlcompat::Union{Nothing, TransmissionModuleCompatibility}=nothing\n) -> Vector{Tuple{Int, Int}}\n\nReturn the index of the add/drop OXC port to allocate at node node If none found, return nothing\n\nchooseoxcadddropport(\n    ibnf::IBNFramework,\n    idagnode::IntentDAGNode{<:ConnectivityIntent},\n    node::LocalNode\n) -> Vector{Int}\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.ipfiltering-Tuple{Any, Any}","page":"API","title":"MINDFul.ipfiltering","text":"ipfiltering(tcp, neighbourips) -> Bool\n\n\nFunction to filter incoming TCP connections based on the IP address. It checks if the IP address of the incoming connection is either localhost or in the list of neighbour IPs. This is useful to prevent unauthorized access to the IBNFramework server.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.is_low_level_intent-Tuple{MINDFul.ConnectivityIntent}","page":"API","title":"MINDFul.is_low_level_intent","text":"is_low_level_intent(ci::MINDFul.ConnectivityIntent) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.isaddportallocation-Tuple{MINDFul.OXCAddDropBypassSpectrumLLI}","page":"API","title":"MINDFul.isaddportallocation","text":"isaddportallocation(\n    oxcswitchentry::MINDFul.OXCAddDropBypassSpectrumLLI\n) -> Bool\n\n\nChecks if this reservation reserves the add port, i.e., it's (0, x, y).\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.isdropportallocation-Tuple{MINDFul.OXCAddDropBypassSpectrumLLI}","page":"API","title":"MINDFul.isdropportallocation","text":"isdropportallocation(\n    oxcswitchentry::MINDFul.OXCAddDropBypassSpectrumLLI\n) -> Bool\n\n\nChecks if this reservation reserves the drop port, i.e., it's (x, y, 0).\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.isinternalorborderintent-Tuple{MINDFul.IBNFramework, MINDFul.ConnectivityIntent}","page":"API","title":"MINDFul.isinternalorborderintent","text":"isinternalorborderintent(\n    ibnf::MINDFul.IBNFramework,\n    connectivityintent::MINDFul.ConnectivityIntent;\n    noremoteintent\n) -> Bool\n\n\nReturn true if at least source or destination is internal. Pass ; noremoteintent=true to check whether there is an OpticalTerminateConstraint or an OpticalInitiateConstraint such that no RemoteIntent is needed.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.isnodeviewinternal-Tuple{MINDFul.NodeView}","page":"API","title":"MINDFul.isnodeviewinternal","text":"isnodeviewinternal(nv::MINDFul.NodeView) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.isonlyoptical-Tuple{MINDFul.EndNodeAllocations}","page":"API","title":"MINDFul.isonlyoptical","text":"isonlyoptical(ena::MINDFul.EndNodeAllocations) -> Bool\n\n\nReturn true if allocaitons on the node do not influence the electrical devices. This is equivalent to the OpticalInitiateConstraint and OpticalTerminateConstraint\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.isoxcllifail-Tuple{MINDFul.IBNFramework, MINDFul.OXCAddDropBypassSpectrumLLI}","page":"API","title":"MINDFul.isoxcllifail","text":"isoxcllifail(\n    ibnf::MINDFul.IBNFramework,\n    oxclli::MINDFul.OXCAddDropBypassSpectrumLLI\n) -> Any\n\n\nReturn true if oxclli is involved with failed equipment\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.isreservationvalid","page":"API","title":"MINDFul.isreservationvalid","text":"isreservationvalid(\n    oxcswitchreservationentry::MINDFul.OXCAddDropBypassSpectrumLLI\n) -> Union{Bool, Symbol}\nisreservationvalid(\n    oxcswitchreservationentry::MINDFul.OXCAddDropBypassSpectrumLLI,\n    verbose::Bool\n) -> Union{Bool, Symbol}\n\n\n\n\n\n\n","category":"function"},{"location":"API/#MINDFul.issatisfied-Tuple{MINDFul.IBNFramework, MINDFul.IntentDAGNode{<:Union{MINDFul.ConnectivityIntent, MINDFul.CrossLightpathIntent}}}","page":"API","title":"MINDFul.issatisfied","text":"issatisfied(\n    ibnf::MINDFul.IBNFramework,\n    idagnode::MINDFul.IntentDAGNode{<:Union{MINDFul.ConnectivityIntent, MINDFul.CrossLightpathIntent}};\n    onlyinstalled,\n    noextrallis,\n    verbose,\n    choosealternativeorder\n) -> Any\n\n\nSteps by step check if ibnf satisfies the intent For now works only with local view. The options are:\n\nonlyinstalled: only consideres installed intents\nnoextrallis: all LLI must be used\norderedllis: pass list to access ordered llis\nchoosealternativeorder::Int. 0 to error in case multiple logical orders are available and the index of the alternative otherwise.\n\nThe function is not a definite assertion. The following cases are not covered:\n\ntransmission module compatibility\noptical reach\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.issubpath-Tuple{Vector{Int64}, Vector{Int64}}","page":"API","title":"MINDFul.issubpath","text":"issubpath(\n    path::Vector{Int64},\n    subpath::Vector{Int64}\n) -> Bool\n\n\nReturn `true` if `subpath` is contained in `path`\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.isthesame-Union{Tuple{T}, Tuple{T, T}} where T","page":"API","title":"MINDFul.isthesame","text":"isthesame(obj1, obj2) -> Any\n\n\nRecursively compare all fields until a primitive element type is found\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.istransmissionmoduleandmodecompatible-Tuple{MINDFul.TransmissionModuleView, Int64, MINDFul.TransmissionModuleCompatibility}","page":"API","title":"MINDFul.istransmissionmoduleandmodecompatible","text":"istransmissionmoduleandmodecompatible(\n    transmissionmoduleview::MINDFul.TransmissionModuleView,\n    transmissionmodesindex::Int64,\n    transmissionmodulecompat::MINDFul.TransmissionModuleCompatibility\n) -> Bool\n\n\nReturn true if the transmissionmoduleview and mode support the transmissionmodulecompat If onlymodecheck = true is passed then the disaggregation/protocol (aka name) will not be checked.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.istransmissionmoduleandmodecompatible-Tuple{MINDFul.TransmissionModuleView, MINDFul.TransmissionMode, MINDFul.TransmissionModuleCompatibility}","page":"API","title":"MINDFul.istransmissionmoduleandmodecompatible","text":"istransmissionmoduleandmodecompatible(\n    transmissionmoduleview::MINDFul.TransmissionModuleView,\n    transmissionmode::MINDFul.TransmissionMode,\n    transmissionmodulecompat::MINDFul.TransmissionModuleCompatibility\n) -> Bool\n\n\nReturn true if the transmissionmoduleview and mode support the transmissionmodulecompat If onlymodecheck = true is passed then the disaggregation/protocol (aka name) will not be checked.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.istransmissionmoduleappropriate-Tuple{MINDFul.TransmissionModuleView, Unitful.Quantity{Float64, Data 𝐓^-1, Unitful.FreeUnits{(Gbps,), Data 𝐓^-1, nothing}}, Unitful.Quantity{Float64, 𝐋, Unitful.FreeUnits{(km,), 𝐋, nothing}}}","page":"API","title":"MINDFul.istransmissionmoduleappropriate","text":"istransmissionmoduleappropriate(\n    transmissionmoduleview::MINDFul.TransmissionModuleView,\n    demandrate::Unitful.Quantity{Float64, Data 𝐓^-1, Unitful.FreeUnits{(Gbps,), Data 𝐓^-1, nothing}},\n    demanddistance::Unitful.Quantity{Float64, 𝐋, Unitful.FreeUnits{(km,), 𝐋, nothing}}\n) -> Bool\n\n\nChecks if the transmission module can get deployed for the given demand rate and distance\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.istransmissionmodulecompatible-Tuple{MINDFul.TransmissionModuleView, MINDFul.TransmissionModuleCompatibility}","page":"API","title":"MINDFul.istransmissionmodulecompatible","text":"istransmissionmodulecompatible(\n    transmissionmoduleview::MINDFul.TransmissionModuleView,\n    transmissionmodulecompat::MINDFul.TransmissionModuleCompatibility\n) -> Bool\n\n\nReturn true if transmissionmoduleview can support with its modes the transmissionmodulecompat\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.logicalordergetelectricalpresence-Tuple{Vector{<:MINDFul.LowLevelIntent}}","page":"API","title":"MINDFul.logicalordergetelectricalpresence","text":"Return a Vector{Int} being the nodes that process electrically the signal\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.logicalordergetlightpaths-Tuple{Vector{<:MINDFul.LowLevelIntent}}","page":"API","title":"MINDFul.logicalordergetlightpaths","text":"logicalordergetlightpaths(\n    lo::Vector{<:MINDFul.LowLevelIntent}\n) -> Vector\n\n\nReturn a Vector{Vector{Int}} being the lightpaths from the logical low level intent order\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.logicalordergetpath-Tuple{Vector{<:MINDFul.LowLevelIntent}}","page":"API","title":"MINDFul.logicalordergetpath","text":"logicalordergetpath(\n    lo::Vector{<:MINDFul.LowLevelIntent}\n) -> Vector{Int64}\n\n\nReturn a Vector{Int} with the path given from the logical low level intent order\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.logicalorderissinglelightpath-Tuple{Vector{<:MINDFul.LowLevelIntent}}","page":"API","title":"MINDFul.logicalorderissinglelightpath","text":"logicalorderissinglelightpath(\n    lo::Vector{<:MINDFul.LowLevelIntent}\n) -> Bool\n\n\nCheck that the LowLevelIntents are consisting a single LightPath implementation\n\nThis means that the order of the LLIs should be (RouterPortLLI) -> (TransmissionModuleLLI) -> OXCAddDropLLI -> (TranmsissionModuleLLI) -> (RouterPortLLI)\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.logintrapathsandinterintents!-Tuple{MINDFul.IBNFramework{A, B, C, D, R} where {A, B, C, D, R<:MINDFul.IntentCompilationAlgorithmWithMemory}, MINDFul.IntentDAGNode}","page":"API","title":"MINDFul.logintrapathsandinterintents!","text":"logintrapathsandinterintents!(\n    ibnf::MINDFul.IBNFramework{A, B, C, D, R} where {A, B, C, D, R<:MINDFul.IntentCompilationAlgorithmWithMemory},\n    idagnode::MINDFul.IntentDAGNode\n)\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.main-Tuple{}","page":"API","title":"MINDFul.main","text":"main(; configfile)\n\n\nmain() function to initialize the MINDFul IBN framework. It expects the path of the configuration file in TOML format, in order to set up the IBNFrameworks for each domain and start the HTTP server that enables communication between domains. The path can be absolute or relative to the current working directory. The paths of the files referenced in the configuration file can be absolute or relative to the directory of the configuration file.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.mycopy-Tuple{T} where T","page":"API","title":"MINDFul.mycopy","text":"mycopy(whatever) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.newoxcentry_adddropallocation","page":"API","title":"MINDFul.newoxcentry_adddropallocation","text":"newoxcentry_adddropallocation(port::Int64)\nnewoxcentry_adddropallocation(\n    port::Int64,\n    spectrumslotsrange::UnitRange{Int64}\n)\n\n\n\n\n\n\n","category":"function"},{"location":"API/#MINDFul.oxcllicontainsedge-Tuple{MINDFul.OXCAddDropBypassSpectrumLLI, Graphs.SimpleGraphs.SimpleEdge}","page":"API","title":"MINDFul.oxcllicontainsedge","text":"oxcllicontainsedge(\n    oxclli::MINDFul.OXCAddDropBypassSpectrumLLI,\n    edge::Graphs.SimpleGraphs.SimpleEdge\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.prioritizegrooming_default-Tuple{MINDFul.IBNFramework, MINDFul.IntentDAGNode{<:MINDFul.ConnectivityIntent}}","page":"API","title":"MINDFul.prioritizegrooming_default","text":"prioritizegrooming_default(\n    ibnf::MINDFul.IBNFramework,\n    idagnode::MINDFul.IntentDAGNode{<:MINDFul.ConnectivityIntent};\n    candidatepaths\n) -> Vector{Vector{Union{Base.UUID, Graphs.SimpleGraphs.SimpleEdge{Int64}}}}\n\n\nReturn a Vector of grooming possibilities.\nSuggest grooming only if remains on the same path.\nSuggest grooming only if one extra router port pair is used.\n\nReturn a `Vector` of grooming possibilities: `Vector{Vector{Union{UUID, Edge{Int}}}}`\nEach element is a `Vector` of either an intent `UUID` or a new connectivity intent defined with `Edge`.\n\nSorting of the grooming possibilities is done just by minimizing lightpaths used\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.prioritizegrooming_exactly-Tuple{MINDFul.IBNFramework{A, B, C, D, MINDFul.BestEmpiricalAvailabilityCompilation} where {A, B, C, D}, MINDFul.IntentDAGNode{<:MINDFul.ConnectivityIntent}}","page":"API","title":"MINDFul.prioritizegrooming_exactly","text":"prioritizegrooming_exactly(\n    ibnf::MINDFul.IBNFramework{A, B, C, D, MINDFul.BestEmpiricalAvailabilityCompilation} where {A, B, C, D},\n    idagnode::MINDFul.IntentDAGNode{<:MINDFul.ConnectivityIntent};\n    candidatepaths\n) -> Vector{Vector{Union{Base.UUID, Graphs.SimpleGraphs.SimpleEdge{Int64}}}}\n\n\nReturn suggestion that match exactly the candidatepaths, such that availability is not changed. All the protection paths need to be matched exactly.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.prioritizegrooming_none-Tuple{MINDFul.IBNFramework, MINDFul.IntentDAGNode{<:MINDFul.ConnectivityIntent}}","page":"API","title":"MINDFul.prioritizegrooming_none","text":"Don't do grooming\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.prioritizepaths_bestempiricalavailability-Tuple{MINDFul.IBNFramework{A, B, C, D, MINDFul.BestEmpiricalAvailabilityCompilation} where {A, B, C, D}, MINDFul.IntentDAGNode{<:MINDFul.ConnectivityIntent}}","page":"API","title":"MINDFul.prioritizepaths_bestempiricalavailability","text":"prioritizepaths_bestempiricalavailability(\n    ibnf::MINDFul.IBNFramework{A, B, C, D, MINDFul.BestEmpiricalAvailabilityCompilation} where {A, B, C, D},\n    idagnode::MINDFul.IntentDAGNode{<:MINDFul.ConnectivityIntent}\n) -> Vector{Vector{Vector{Int64}}}\n\n\nReturn a Vector{Vector{Int}} vector of vector of paths. Each element in the outer vector is a combination of paths to be used for protection. The first path is supposed to be the one deployed and all other are the protection. Constrained to return protection only up to 2 paths\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.prioritizepaths_shortest-Tuple{MINDFul.IBNFramework, MINDFul.IntentDAGNode{<:MINDFul.ConnectivityIntent}}","page":"API","title":"MINDFul.prioritizepaths_shortest","text":"prioritizepaths_shortest(\n    ibnf::MINDFul.IBNFramework,\n    idagnode::MINDFul.IntentDAGNode{<:MINDFul.ConnectivityIntent}\n) -> Vector{Vector{Vector{Int64}}}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.prioritizerouterports_default","page":"API","title":"MINDFul.prioritizerouterports_default","text":"prioritizerouterports_default(\n    ibnf::MINDFul.IBNFramework,\n    idagnode::MINDFul.IntentDAGNode{<:MINDFul.ConnectivityIntent},\n    node::Int64\n) -> Vector{Int64}\nprioritizerouterports_default(\n    ibnf::MINDFul.IBNFramework,\n    idagnode::MINDFul.IntentDAGNode{<:MINDFul.ConnectivityIntent},\n    node::Int64,\n    transmissionmoderate::Unitful.Quantity{Float64, Data 𝐓^-1, Unitful.FreeUnits{(Gbps,), Data 𝐓^-1, nothing}}\n) -> Vector{Int64}\n\n\n\n\n\n\n","category":"function"},{"location":"API/#MINDFul.prioritizerouterports_lowestrate","page":"API","title":"MINDFul.prioritizerouterports_lowestrate","text":"prioritizerouterports_lowestrate(\n    ibnf::MINDFul.IBNFramework,\n    idagnode::MINDFul.IntentDAGNode{<:MINDFul.ConnectivityIntent},\n    node::Int64\n) -> Vector{Int64}\nprioritizerouterports_lowestrate(\n    ibnf::MINDFul.IBNFramework,\n    idagnode::MINDFul.IntentDAGNode{<:MINDFul.ConnectivityIntent},\n    node::Int64,\n    transmissionmoderate::Unitful.Quantity{Float64, Data 𝐓^-1, Unitful.FreeUnits{(Gbps,), Data 𝐓^-1, nothing}}\n) -> Vector{Int64}\n\n\nSame as prioritizerouterports_lowestrate but with a sort! in the end\n\n\n\n\n\n","category":"function"},{"location":"API/#MINDFul.prioritizesplitbordernodes_shortestorshortestrandom-Tuple{MINDFul.IBNFramework, MINDFul.IntentDAGNode{<:MINDFul.ConnectivityIntent}}","page":"API","title":"MINDFul.prioritizesplitbordernodes_shortestorshortestrandom","text":"prioritizesplitbordernodes_shortestorshortestrandom(\n    ibnf::MINDFul.IBNFramework,\n    idagnode::MINDFul.IntentDAGNode{<:MINDFul.ConnectivityIntent}\n) -> Vector\n\n\nReturn a priority list of GlobalNode. If the target domain is known return the GlobalNode with the shortest distance. If the target domain is unknown return the border node with the shortest distance, excluding the (if) source domain.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.prioritizesplitnodes_longestfirstshortestpath-Tuple{MINDFul.IBNFramework, MINDFul.IntentDAGNode{<:MINDFul.ConnectivityIntent}}","page":"API","title":"MINDFul.prioritizesplitnodes_longestfirstshortestpath","text":"prioritizesplitnodes_longestfirstshortestpath(\n    ibnf::MINDFul.IBNFramework,\n    idagnode::MINDFul.IntentDAGNode{<:MINDFul.ConnectivityIntent}\n) -> Vector{MINDFul.SplitGlobalNode}\n\n\nReturn the GlobalNode contained in the shortest path that is the longest to reach given the optical reach situation. The GlobalNode is used to break up the ConnectivityIntent into two. This is irrelevant to all availabilities decision. It just adapts the availability constraints based on the estimations.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.prioritizetransmdlmode_cheaplowrate","page":"API","title":"MINDFul.prioritizetransmdlmode_cheaplowrate","text":"prioritizetransmdlmode_cheaplowrate(\n    ibnf::MINDFul.IBNFramework,\n    idagnode::MINDFul.IntentDAGNode{<:MINDFul.ConnectivityIntent},\n    node::Int64,\n    path::Union{Nothing, Vector{Int64}},\n    routerportrate::Unitful.Quantity{Float64, Data 𝐓^-1, Unitful.FreeUnits{(Gbps,), Data 𝐓^-1, nothing}}\n) -> Vector{Tuple{Int64, Int64}}\nprioritizetransmdlmode_cheaplowrate(\n    ibnf::MINDFul.IBNFramework,\n    idagnode::MINDFul.IntentDAGNode{<:MINDFul.ConnectivityIntent},\n    node::Int64,\n    path::Union{Nothing, Vector{Int64}},\n    routerportrate::Unitful.Quantity{Float64, Data 𝐓^-1, Unitful.FreeUnits{(Gbps,), Data 𝐓^-1, nothing}},\n    transmdlcompat::Union{Nothing, MINDFul.TransmissionModuleCompatibility}\n) -> Vector{Tuple{Int64, Int64}}\n\n\nSame as prioritizetransmdlmode_default with a sortperm! Return the index with the lowest GBPS rate that can get deployed for the given demand rate and distance. If non is find return nothing.\n\n\n\n\n\n","category":"function"},{"location":"API/#MINDFul.prioritizetransmdlmode_default","page":"API","title":"MINDFul.prioritizetransmdlmode_default","text":"prioritizetransmdlmode_default(\n    ibnf::MINDFul.IBNFramework,\n    idagnode::MINDFul.IntentDAGNode{<:MINDFul.ConnectivityIntent},\n    node::Int64,\n    path::Union{Nothing, Vector{Int64}},\n    routerportrate::Unitful.Quantity{Float64, Data 𝐓^-1, Unitful.FreeUnits{(Gbps,), Data 𝐓^-1, nothing}}\n) -> Vector{Tuple{Int64, Int64}}\nprioritizetransmdlmode_default(\n    ibnf::MINDFul.IBNFramework,\n    idagnode::MINDFul.IntentDAGNode{<:MINDFul.ConnectivityIntent},\n    node::Int64,\n    path::Union{Nothing, Vector{Int64}},\n    routerportrate::Unitful.Quantity{Float64, Data 𝐓^-1, Unitful.FreeUnits{(Gbps,), Data 𝐓^-1, nothing}},\n    transmdlcompat::Union{Nothing, MINDFul.TransmissionModuleCompatibility}\n) -> Vector{Tuple{Int64, Int64}}\n\n\n\n\n\n\n","category":"function"},{"location":"API/#MINDFul.pushstatetoidagnode!-Tuple{Array{Tuple{Dates.DateTime, S}, 1} where S<:Enum{Int32}, MINDFul.IntentState.T}","page":"API","title":"MINDFul.pushstatetoidagnode!","text":"pushstatetoidagnode!(\n    intentlogstate::Array{Tuple{Dates.DateTime, S}, 1} where S<:Enum{Int32},\n    intentstate::MINDFul.IntentState.T;\n    offsettime\n) -> Array{Tuple{Dates.DateTime, S}, 1} where S<:Enum{Int32}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.pushstatetoidagnode!-Tuple{MINDFul.IntentDAGNode, MINDFul.IntentState.T}","page":"API","title":"MINDFul.pushstatetoidagnode!","text":"pushstatetoidagnode!(\n    idagnode::MINDFul.IntentDAGNode,\n    intentstate::MINDFul.IntentState.T;\n    offsettime\n) -> Vector{Tuple{Dates.DateTime, MINDFul.IntentState.T}}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.readb64keys-Tuple{String}","page":"API","title":"MINDFul.readb64keys","text":"readb64keys(finalkeyfile::String) -> String\n\n\nFunction to read a base64 encoded key from a PEM file.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.removefrominstalledlightpaths!-Tuple{MINDFul.IBNFramework, MINDFul.IntentDAGNode}","page":"API","title":"MINDFul.removefrominstalledlightpaths!","text":"removefrominstalledlightpaths!(\n    ibnf::MINDFul.IBNFramework,\n    idagnode::MINDFul.IntentDAGNode\n) -> Bool\n\n\nRemove from the installedlightpaths representation if exists Return true if done. Otherwise false\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.removeidagedge!-Tuple{AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo}, Base.UUID, Base.UUID}","page":"API","title":"MINDFul.removeidagedge!","text":"removeidagedge!(\n    idag::AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo},\n    fromnode::Base.UUID,\n    tonode::Base.UUID\n) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.requestavailablecompilationalgorithms_init!-Tuple{MINDFul.IBNFramework, MINDFul.IBNFramework}","page":"API","title":"MINDFul.requestavailablecompilationalgorithms_init!","text":"requestavailablecompilationalgorithms_init!(\n    myibnf::MINDFul.IBNFramework,\n    remoteibnf::MINDFul.IBNFramework\n) -> Vector\n\n\nCompilation algorithms are given as symbols because they might not be available programmatically to different IBN frameworks\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.requestavailablecompilationalgorithms_init!-Tuple{MINDFul.IBNFramework, MINDFul.RemoteHTTPHandler}","page":"API","title":"MINDFul.requestavailablecompilationalgorithms_init!","text":"requestavailablecompilationalgorithms_init!(\n    myibnf::MINDFul.IBNFramework,\n    remoteibnfhandler::MINDFul.RemoteHTTPHandler\n) -> Any\n\n\nMA1069 implementation\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.requestcompileintent_init!","page":"API","title":"MINDFul.requestcompileintent_init!","text":"requestcompileintent_init!(\n    myibnf::MINDFul.IBNFramework,\n    remoteibnfhandler::MINDFul.RemoteHTTPHandler,\n    idagnodeid::Base.UUID;\n    ...\n) -> Any\nrequestcompileintent_init!(\n    myibnf::MINDFul.IBNFramework,\n    remoteibnfhandler::MINDFul.RemoteHTTPHandler,\n    idagnodeid::Base.UUID,\n    compilationalgorithmkey::Symbol;\n    ...\n) -> Any\nrequestcompileintent_init!(\n    myibnf::MINDFul.IBNFramework,\n    remoteibnfhandler::MINDFul.RemoteHTTPHandler,\n    idagnodeid::Base.UUID,\n    compilationalgorithmkey::Symbol,\n    compilationalgorithmargs::Tuple;\n    verbose,\n    offsettime\n) -> Any\n\n\nMA1069 implementation\n\n\n\n\n\n","category":"function"},{"location":"API/#MINDFul.requestcompileintent_init!-Tuple{MINDFul.IBNFramework, MINDFul.IBNFramework, Base.UUID}","page":"API","title":"MINDFul.requestcompileintent_init!","text":"requestcompileintent_init!(\n    myibnf::MINDFul.IBNFramework,\n    remoteibnf::MINDFul.IBNFramework,\n    idagnodeid::Base.UUID;\n    verbose,\n    offsettime\n) -> Symbol\n\n\nThe initiator domain myibnf asks remoteibnf to compile the external remote intent idagnodeid with the specified compilation algorithm\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.requestcompileintent_term!-Tuple{MINDFul.AbstractIBNFHandler, MINDFul.IBNFramework, Base.UUID}","page":"API","title":"MINDFul.requestcompileintent_term!","text":"requestcompileintent_term!(\n    remoteibnfhandler::MINDFul.AbstractIBNFHandler,\n    myibnf::MINDFul.IBNFramework,\n    idagnodeid::Base.UUID;\n    verbose,\n    offsettime\n) -> Symbol\n\n\nThe initiator domain remoteibnf asks this domain myibnf to compile the internal remote intent idagnodeid with the specified compilation algorithm\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.requestcurrentlinkstate_init-Tuple{MINDFul.IBNFramework, MINDFul.IBNFramework, MINDFul.GlobalEdge}","page":"API","title":"MINDFul.requestcurrentlinkstate_init","text":"requestcurrentlinkstate_init(\n    myibnf::MINDFul.IBNFramework,\n    remoteibnf::MINDFul.IBNFramework,\n    ge::MINDFul.GlobalEdge\n) -> Union{Nothing, Bool}\n\n\nRequest the link state of the border edge Need to check whether ge is indeed an edge shared with myibnf\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.requestcurrentlinkstate_term-Tuple{MINDFul.AbstractIBNFHandler, MINDFul.IBNFramework, MINDFul.GlobalEdge}","page":"API","title":"MINDFul.requestcurrentlinkstate_term","text":"requestcurrentlinkstate_term(\n    remoteibnfhandler::MINDFul.AbstractIBNFHandler,\n    myibnf::MINDFul.IBNFramework,\n    ge::MINDFul.GlobalEdge\n) -> Union{Nothing, Bool}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.requestdelegateintent_init!-Tuple{MINDFul.IBNFramework, MINDFul.IBNFramework, MINDFul.AbstractIntent, Base.UUID}","page":"API","title":"MINDFul.requestdelegateintent_init!","text":"requestdelegateintent_init!(\n    myibnf::MINDFul.IBNFramework,\n    remoteibnf::MINDFul.IBNFramework,\n    intent::MINDFul.AbstractIntent,\n    internalidagnodeid::Base.UUID;\n    offsettime\n) -> Base.UUID\n\n\nReturn the id of the new dag node if successful and nothing otherwise\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.requestdelegateintent_init!-Tuple{MINDFul.IBNFramework, MINDFul.RemoteHTTPHandler, MINDFul.AbstractIntent, Base.UUID}","page":"API","title":"MINDFul.requestdelegateintent_init!","text":"requestdelegateintent_init!(\n    myibnf::MINDFul.IBNFramework,\n    remoteibnfhandler::MINDFul.RemoteHTTPHandler,\n    intent::MINDFul.AbstractIntent,\n    internalidagnodeid::Base.UUID;\n    offsettime\n) -> Any\n\n\nMA1069 implementation\n\nDelegates an intent to another domain\n\nReturn the id of the new dag node if successful and nothing otherwise\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.requestglobalnodeelectricalpresence_init-Tuple{MINDFul.IBNFramework, MINDFul.IBNFramework, Base.UUID}","page":"API","title":"MINDFul.requestglobalnodeelectricalpresence_init","text":"requestglobalnodeelectricalpresence_init(\n    myibnf::MINDFul.IBNFramework,\n    remoteibnf::MINDFul.IBNFramework,\n    intentuuid::Base.UUID;\n    onlyinstalled\n) -> Any\n\n\nRequest the path that is implementing intent intentuuid in the remote IBN framework as global node vector\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.requestglobalnodeelectricalpresence_term-Tuple{MINDFul.AbstractIBNFHandler, MINDFul.IBNFramework, Base.UUID}","page":"API","title":"MINDFul.requestglobalnodeelectricalpresence_term","text":"requestglobalnodeelectricalpresence_term(\n    remoteibnfhandler::MINDFul.AbstractIBNFHandler,\n    myibnf::MINDFul.IBNFramework,\n    intentuuid::Base.UUID;\n    onlyinstalled\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.requestibnattributegraph_init-Tuple{MINDFul.IBNFramework, MINDFul.IBNFramework}","page":"API","title":"MINDFul.requestibnattributegraph_init","text":"requestibnattributegraph_init(\n    myibnf::MINDFul.IBNFramework,\n    remoteibnf::MINDFul.IBNFramework\n) -> AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView\n\n\nRequest topology information\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.requestibnattributegraph_term!-Tuple{MINDFul.AbstractIBNFHandler, MINDFul.IBNFramework}","page":"API","title":"MINDFul.requestibnattributegraph_term!","text":"requestibnattributegraph_term!(\n    remoteibnfhandler::MINDFul.AbstractIBNFHandler,\n    myibnf::MINDFul.IBNFramework\n) -> AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{T}, Dict{Graphs.SimpleGraphs.SimpleEdge{Int64}, MINDFul.EdgeView}, Base.UUID} where T<:MINDFul.NodeView\n\n\nMA1069 implementation If far away, think about authorization and permissions. That's the reason why there are 2 arguments: The first argument should have the authorization.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.requestibnfhandlers_init-Tuple{MINDFul.IBNFramework, MINDFul.IBNFramework}","page":"API","title":"MINDFul.requestibnfhandlers_init","text":"requestibnfhandlers_init(\n    myibnf::MINDFul.IBNFramework,\n    remoteibnf::MINDFul.IBNFramework\n) -> Vector{H} where H<:MINDFul.AbstractIBNFHandler\n\n\nRequest the handlers of the handler\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.requestidag_init-Tuple{MINDFul.IBNFramework, MINDFul.IBNFramework}","page":"API","title":"MINDFul.requestidag_init","text":"requestidag_init(\n    myibnf::MINDFul.IBNFramework,\n    remoteibnf::MINDFul.IBNFramework\n) -> AttributeGraphs.AttributeGraph{Int64, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, Vector{MINDFul.IntentDAGNode}, Nothing, MINDFul.IntentDAGInfo}\n\n\nRequest intent dag information\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.requestidag_init-Tuple{MINDFul.IBNFramework, MINDFul.RemoteHTTPHandler}","page":"API","title":"MINDFul.requestidag_init","text":"MA1069 implementation\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.requestinstallintent_init!-Tuple{MINDFul.IBNFramework, MINDFul.IBNFramework, Base.UUID}","page":"API","title":"MINDFul.requestinstallintent_init!","text":"requestinstallintent_init!(\n    myibnf::MINDFul.IBNFramework,\n    remoteibnf::MINDFul.IBNFramework,\n    idagnodeid::Base.UUID;\n    verbose,\n    offsettime\n) -> MINDFul.ReturnCodeTime\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.requestinstallintent_term!-Tuple{MINDFul.AbstractIBNFHandler, MINDFul.IBNFramework, Base.UUID}","page":"API","title":"MINDFul.requestinstallintent_term!","text":"requestinstallintent_term!(\n    remoteibnfhandler::MINDFul.AbstractIBNFHandler,\n    myibnf::MINDFul.IBNFramework,\n    idagnodeid::Base.UUID;\n    verbose,\n    offsettime\n) -> MINDFul.ReturnCodeTime\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.requestintentgloballightpaths_init-Tuple{MINDFul.IBNFramework, MINDFul.IBNFramework, Base.UUID}","page":"API","title":"MINDFul.requestintentgloballightpaths_init","text":"requestintentgloballightpaths_init(\n    myibnf::MINDFul.IBNFramework,\n    remoteibnf::MINDFul.IBNFramework,\n    intentuuid::Base.UUID;\n    onlyinstalled\n) -> Vector\n\n\nRequest the path that is implementing intent intentuuid in the remote IBN framework as global node vector\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.requestintentgloballightpaths_term-Tuple{MINDFul.AbstractIBNFHandler, MINDFul.IBNFramework, Base.UUID}","page":"API","title":"MINDFul.requestintentgloballightpaths_term","text":"requestintentgloballightpaths_term(\n    remoteibnfhandler::MINDFul.AbstractIBNFHandler,\n    myibnf::MINDFul.IBNFramework,\n    intentuuid::Base.UUID;\n    onlyinstalled\n) -> Vector\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.requestintentglobalpath_init-Tuple{MINDFul.IBNFramework, MINDFul.IBNFramework, Base.UUID}","page":"API","title":"MINDFul.requestintentglobalpath_init","text":"requestintentglobalpath_init(\n    myibnf::MINDFul.IBNFramework,\n    remoteibnf::MINDFul.IBNFramework,\n    intentuuid::Base.UUID;\n    onlyinstalled\n) -> Vector\n\n\nRequest the path that is implementing intent intentuuid in the remote IBN framework as global node vector\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.requestintentglobalpath_term-Tuple{MINDFul.AbstractIBNFHandler, MINDFul.IBNFramework, Base.UUID}","page":"API","title":"MINDFul.requestintentglobalpath_term","text":"requestintentglobalpath_term(\n    remoteibnfhandler::MINDFul.AbstractIBNFHandler,\n    myibnf::MINDFul.IBNFramework,\n    intentuuid::Base.UUID;\n    onlyinstalled\n) -> Vector\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.requestissatisfied_init-Tuple{MINDFul.IBNFramework, MINDFul.IBNFramework, Base.UUID}","page":"API","title":"MINDFul.requestissatisfied_init","text":"requestissatisfied_init(\n    myibnf::MINDFul.IBNFramework,\n    remoteibnf::MINDFul.IBNFramework,\n    idagnodeid::Base.UUID;\n    onlyinstalled,\n    noextrallis,\n    choosealternativeorder\n) -> Any\n\n\nRequest to remoteibnf whether the idagnode is theoretically satisfied\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.requestissatisfied_init-Tuple{MINDFul.IBNFramework, MINDFul.RemoteHTTPHandler, Base.UUID}","page":"API","title":"MINDFul.requestissatisfied_init","text":"requestissatisfied_init(\n    myibnf::MINDFul.IBNFramework,\n    remoteibnfhandler::MINDFul.RemoteHTTPHandler,\n    idagnodeid::Base.UUID;\n    onlyinstalled,\n    noextrallis,\n    choosealternativeorder\n) -> Any\n\n\nMA1069 implementation\n\nRequest to remoteibnf whether the idagnode is theoretically satisfied\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.requestlinkstates_init-Tuple{MINDFul.IBNFramework, MINDFul.IBNFramework, MINDFul.GlobalEdge}","page":"API","title":"MINDFul.requestlinkstates_init","text":"requestlinkstates_init(\n    myibnf::MINDFul.IBNFramework,\n    remoteibnf::MINDFul.IBNFramework,\n    ge::MINDFul.GlobalEdge\n) -> Union{Nothing, Vector{Tuple{Dates.DateTime, Bool}}}\n\n\nRequest all the link states of the border edge Need to check whether ge is indeed an edge shared with myibnf\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.requestlogicallliorder_init-Tuple{MINDFul.IBNFramework, MINDFul.IBNFramework, Base.UUID}","page":"API","title":"MINDFul.requestlogicallliorder_init","text":"requestlogicallliorder_init(\n    myibnf::MINDFul.IBNFramework,\n    remoteibnf::MINDFul.IBNFramework,\n    intentuuid::Base.UUID;\n    onlyinstalled,\n    verbose\n) -> Union{Bool, Vector{MINDFul.LowLevelIntent}}\n\n\nRequest logical low level intent sequence\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.requestremoteintentstateupdate_init!-Tuple{MINDFul.IBNFramework, MINDFul.IBNFramework, Base.UUID, MINDFul.IntentState.T}","page":"API","title":"MINDFul.requestremoteintentstateupdate_init!","text":"requestremoteintentstateupdate_init!(\n    myibnf::MINDFul.IBNFramework,\n    remoteibnf::MINDFul.IBNFramework,\n    idagnodeid::Base.UUID,\n    newstate::MINDFul.IntentState.T;\n    offsettime\n) -> Bool\n\n\nRequest the initiator remoteibnf to update the state of its mirrored remote intent\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.requestsetlinkstate_init!-Tuple{MINDFul.IBNFramework, MINDFul.IBNFramework, MINDFul.GlobalEdge, Bool}","page":"API","title":"MINDFul.requestsetlinkstate_init!","text":"requestsetlinkstate_init!(\n    myibnf::MINDFul.IBNFramework,\n    remoteibnf::MINDFul.IBNFramework,\n    ge::MINDFul.GlobalEdge,\n    operatingstate::Bool;\n    offsettime\n) -> Union{Nothing, MINDFul.ReturnCodeTime}\n\n\nRequest to set the state of the neighboring link\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.requestsetlinkstate_term!-Tuple{MINDFul.AbstractIBNFHandler, MINDFul.IBNFramework, MINDFul.GlobalEdge, Bool}","page":"API","title":"MINDFul.requestsetlinkstate_term!","text":"requestsetlinkstate_term!(\n    remoteibnfhandler::MINDFul.AbstractIBNFHandler,\n    myibnf::MINDFul.IBNFramework,\n    ge::MINDFul.GlobalEdge,\n    operatingstate::Bool;\n    offsettime\n) -> Union{Nothing, MINDFul.ReturnCodeTime}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.requestspectrumavailability_init!-Tuple{MINDFul.IBNFramework, MINDFul.IBNFramework, MINDFul.GlobalEdge}","page":"API","title":"MINDFul.requestspectrumavailability_init!","text":"requestspectrumavailability_init!(\n    myibnf::MINDFul.IBNFramework,\n    remoteibnf::MINDFul.IBNFramework,\n    ge::MINDFul.GlobalEdge\n) -> Union{Nothing, Vector{Bool}}\n\n\nRequest spectrum slot availabilities of the border edge Need to check whether ge is indeed an edge shared with myibnf\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.requestspectrumavailability_init!-Tuple{MINDFul.IBNFramework, MINDFul.RemoteHTTPHandler, MINDFul.GlobalEdge}","page":"API","title":"MINDFul.requestspectrumavailability_init!","text":"requestspectrumavailability_init!(\n    myibnf::MINDFul.IBNFramework,\n    remoteibnfhandler::MINDFul.RemoteHTTPHandler,\n    ge::MINDFul.GlobalEdge\n) -> Any\n\n\nMA1069 implementation\n\nRequest spectr /um slot availabilities of the border edge Need to check whether ge is indeed an edge shared with myibnf\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.requestuncompileintent_init!-Tuple{MINDFul.IBNFramework, MINDFul.IBNFramework, Base.UUID}","page":"API","title":"MINDFul.requestuncompileintent_init!","text":"requestuncompileintent_init!(\n    myibnf::MINDFul.IBNFramework,\n    remoteibnf::MINDFul.IBNFramework,\n    idagnodeid::Base.UUID;\n    verbose,\n    offsettime\n) -> Symbol\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.requestuncompileintent_term!-Tuple{MINDFul.AbstractIBNFHandler, MINDFul.IBNFramework, Base.UUID}","page":"API","title":"MINDFul.requestuncompileintent_term!","text":"requestuncompileintent_term!(\n    remoteibnfhandler::MINDFul.AbstractIBNFHandler,\n    myibnf::MINDFul.IBNFramework,\n    idagnodeid::Base.UUID;\n    verbose,\n    offsettime\n) -> Symbol\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.requestuninstallintent_init!-Tuple{MINDFul.IBNFramework, MINDFul.IBNFramework, Base.UUID}","page":"API","title":"MINDFul.requestuninstallintent_init!","text":"requestuninstallintent_init!(\n    myibnf::MINDFul.IBNFramework,\n    remoteibnf::MINDFul.IBNFramework,\n    idagnodeid::Base.UUID;\n    verbose,\n    offsettime\n) -> MINDFul.ReturnCodeTime\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.requestuninstallintent_term!-Tuple{MINDFul.AbstractIBNFHandler, MINDFul.IBNFramework, Base.UUID}","page":"API","title":"MINDFul.requestuninstallintent_term!","text":"requestuninstallintent_term!(\n    remoteibnfhandler::MINDFul.AbstractIBNFHandler,\n    myibnf::MINDFul.IBNFramework,\n    idagnodeid::Base.UUID;\n    verbose,\n    offsettime\n) -> MINDFul.ReturnCodeTime\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.reserve!-Tuple{MINDFul.AbstractSDNController, MINDFul.ReservableResourceView, MINDFul.LowLevelIntent, Base.UUID}","page":"API","title":"MINDFul.reserve!","text":"reserve!(\n    sdn::MINDFul.AbstractSDNController,\n    resourceview::MINDFul.ReservableResourceView,\n    lowlevelintent::MINDFul.LowLevelIntent,\n    dagnodeid::Base.UUID;\n    checkfirst,\n    verbose\n) -> Symbol\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.reserveunreserveleafintents!-Tuple{MINDFul.IBNFramework, MINDFul.IntentDAGNode, Bool}","page":"API","title":"MINDFul.reserveunreserveleafintents!","text":"reserveunreserveleafintents!(\n    ibnf::MINDFul.IBNFramework,\n    idagnodeleaf::MINDFul.IntentDAGNode,\n    doinstall::Bool;\n    verbose,\n    offsettime\n) -> Bool\n\n\nto reserve pass doinstall=true, and to unreserve doinstall=false\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.rsaauthentication_encrypt-Tuple{MINDFul.RemoteHTTPHandler, String}","page":"API","title":"MINDFul.rsaauthentication_encrypt","text":"rsaauthentication_encrypt(\n    remoteibnfhandler::MINDFul.RemoteHTTPHandler,\n    unencryptedsecret::String\n) -> String\n\n\nFunction to perform RSA encryption on a secret using the public key of the remote IBNF.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.rsaauthentication_init-Tuple{MINDFul.IBNFramework, MINDFul.RemoteHTTPHandler}","page":"API","title":"MINDFul.rsaauthentication_init","text":"rsaauthentication_init(\n    ibnf::MINDFul.IBNFramework,\n    remoteibnfhandler::MINDFul.RemoteHTTPHandler\n) -> String\n\n\nExchange of encrypted secrets via RSA algorithm for mutual authentication with the remote domain. The initiator domain will generate a secret, encrypt it with the public key of the remote domain, and send it. The remote domain will decrypt the secret with its private key, and return the decrypted secret concatenated with a new secret (the concatenation is encrypted with the initiator's public key). The initiator domain will then decrypt with its private key, check the initial secret and return the new secret encrypted in the handshake.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.sendrequest-Tuple{MINDFul.IBNFramework, MINDFul.RemoteHTTPHandler, String, Dict}","page":"API","title":"MINDFul.sendrequest","text":"sendrequest(\n    ibnf::MINDFul.IBNFramework,\n    remotehandler::MINDFul.RemoteHTTPHandler,\n    endpoint::String,\n    data::Dict;\n    offsettime\n) -> Response\n\n\nFunction used to send a request to a remote IBNFramework handler. It also handles the initial authentication and sends the requests with the provided data.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.setadddropport!-Tuple{MINDFul.MutableEndNodeAllocations, Union{Nothing, Int64}}","page":"API","title":"MINDFul.setadddropport!","text":"setadddropport!(\n    ena::MINDFul.MutableEndNodeAllocations,\n    intval::Union{Nothing, Int64}\n) -> Union{Nothing, Int64}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.setavailabilityrequirement!-Tuple{MINDFul.MutableAvailabilityConstraint, Float64}","page":"API","title":"MINDFul.setavailabilityrequirement!","text":"setavailabilityrequirement!(\n    mav::MINDFul.MutableAvailabilityConstraint,\n    newval::Float64\n) -> Float64\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.setcompliancetarget!-Tuple{MINDFul.MutableAvailabilityConstraint, Float64}","page":"API","title":"MINDFul.setcompliancetarget!","text":"setcompliancetarget!(\n    mav::MINDFul.MutableAvailabilityConstraint,\n    newval::Float64\n) -> Float64\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.setdatetime!-Tuple{MINDFul.BasicAlgorithmMemory, Dates.DateTime}","page":"API","title":"MINDFul.setdatetime!","text":"setdatetime!(\n    intcompalg::MINDFul.BasicAlgorithmMemory,\n    currentdatetime::Dates.DateTime\n) -> Dates.DateTime\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.setdatetime!-Tuple{MINDFul.IntentCompilationAlgorithm, Dates.DateTime}","page":"API","title":"MINDFul.setdatetime!","text":"setdatetime!(\n    intcompalg::MINDFul.IntentCompilationAlgorithm,\n    currentdatetime::Dates.DateTime\n) -> Dates.DateTime\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.setibnfhandlergentoken!-Tuple{MINDFul.AbstractIBNFHandler, String}","page":"API","title":"MINDFul.setibnfhandlergentoken!","text":"setibnfhandlergentoken!(\n    remotehandler::MINDFul.AbstractIBNFHandler,\n    generatedtoken::String\n) -> String\n\n\nSet the generated token for authenticating a remote domain.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.setibnfhandlerrecvtoken!-Tuple{MINDFul.AbstractIBNFHandler, String}","page":"API","title":"MINDFul.setibnfhandlerrecvtoken!","text":"setibnfhandlerrecvtoken!(\n    remotehandler::MINDFul.AbstractIBNFHandler,\n    receivedtoken::String\n) -> String\n\n\nSet the received token for authenticating to a remote domain.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.setibnfhandlerrsasecret!-Tuple{MINDFul.RemoteHTTPHandler, String}","page":"API","title":"MINDFul.setibnfhandlerrsasecret!","text":"setibnfhandlerrsasecret!(\n    remotehandler::MINDFul.RemoteHTTPHandler,\n    secret::String\n) -> String\n\n\nSet the RSA secret for authenticating a remote domain.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.setibnfserver!-Tuple{MINDFul.IBNFramework, Union{HTTP.Servers.Server{HTTP.Servers.Listener{Nothing, Sockets.TCPServer}}, HTTP.Servers.Server{HTTP.Servers.Listener{MbedTLS.SSLConfig, Sockets.TCPServer}}}}","page":"API","title":"MINDFul.setibnfserver!","text":"setibnfserver!(\n    ibnf::MINDFul.IBNFramework,\n    server::Union{HTTP.Servers.Server{HTTP.Servers.Listener{Nothing, Sockets.TCPServer}}, HTTP.Servers.Server{HTTP.Servers.Listener{MbedTLS.SSLConfig, Sockets.TCPServer}}}\n) -> Union{HTTP.Servers.Server{HTTP.Servers.Listener{Nothing, Sockets.TCPServer}}, HTTP.Servers.Server{HTTP.Servers.Listener{MbedTLS.SSLConfig, Sockets.TCPServer}}}\n\n\nSet the running server of an IBNFramework.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.setlinkstate!-Tuple{MINDFul.IBNFramework, Graphs.SimpleGraphs.SimpleEdge, Bool}","page":"API","title":"MINDFul.setlinkstate!","text":"setlinkstate!(\n    ibnf::MINDFul.IBNFramework,\n    edge::Graphs.SimpleGraphs.SimpleEdge,\n    operatingstate::Bool;\n    offsettime\n) -> MINDFul.ReturnCodeTime\n\n\nSet the link state on both OXCView ends of edge\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.setlinkstate!-Tuple{MINDFul.IBNFramework, MINDFul.OXCView, Graphs.SimpleGraphs.SimpleEdge, Bool}","page":"API","title":"MINDFul.setlinkstate!","text":"setlinkstate!(\n    ibnf::MINDFul.IBNFramework,\n    oxcview::MINDFul.OXCView,\n    edge::Graphs.SimpleGraphs.SimpleEdge,\n    operatingstate::Bool;\n    offsettime\n) -> MINDFul.ReturnCodeTime\n\n\nSet the operating state of the edge in oxcview and trigger the state update of the relevant low level intents.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.setlocalnode!-Tuple{MINDFul.MutableEndNodeAllocations, Union{Nothing, Int64}}","page":"API","title":"MINDFul.setlocalnode!","text":"setlocalnode!(\n    ena::MINDFul.MutableEndNodeAllocations,\n    intval::Union{Nothing, Int64}\n) -> Union{Nothing, Int64}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.setlocalnode_input!-Tuple{MINDFul.MutableEndNodeAllocations, Union{Nothing, Int64}}","page":"API","title":"MINDFul.setlocalnode_input!","text":"setlocalnode_input!(\n    ena::MINDFul.MutableEndNodeAllocations,\n    intval::Union{Nothing, Int64}\n) -> Union{Nothing, Int64}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.setlocalnode_output!-Tuple{MINDFul.MutableEndNodeAllocations, Union{Nothing, Int64}}","page":"API","title":"MINDFul.setlocalnode_output!","text":"setlocalnode_output!(\n    ena::MINDFul.MutableEndNodeAllocations,\n    intval::Union{Nothing, Int64}\n)\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.setoxcviewlinkavailabilities!-Tuple{MINDFul.OXCView, MINDFul.OXCAddDropBypassSpectrumLLI, Bool}","page":"API","title":"MINDFul.setoxcviewlinkavailabilities!","text":"setoxcviewlinkavailabilities!(\n    oxcview::MINDFul.OXCView,\n    oxcadddropbypassspectrumlli::MINDFul.OXCAddDropBypassSpectrumLLI,\n    setflag::Bool;\n    verbose\n) -> Symbol\n\n\nSet the link spectrum availabilities of the oxcview based on the OXC low level intent to setflags\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.setrouterportindex!-Tuple{MINDFul.MutableEndNodeAllocations, Union{Nothing, Int64}}","page":"API","title":"MINDFul.setrouterportindex!","text":"setrouterportindex!(\n    ena::MINDFul.MutableEndNodeAllocations,\n    intval::Union{Nothing, Int64}\n) -> Union{Nothing, Int64}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.settransmissionmodesindex!-Tuple{MINDFul.MutableEndNodeAllocations, Union{Nothing, Int64}}","page":"API","title":"MINDFul.settransmissionmodesindex!","text":"settransmissionmodesindex!(\n    ena::MINDFul.MutableEndNodeAllocations,\n    intval::Union{Nothing, Int64}\n) -> Union{Nothing, Int64}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.settransmissionmoduleviewpoolindex!-Tuple{MINDFul.MutableEndNodeAllocations, Union{Nothing, Int64}}","page":"API","title":"MINDFul.settransmissionmoduleviewpoolindex!","text":"settransmissionmoduleviewpoolindex!(\n    ena::MINDFul.MutableEndNodeAllocations,\n    intval::Union{Nothing, Int64}\n) -> Union{Nothing, Int64}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.splitandcompilecrossdomainconnectivityintent-Union{Tuple{F}, Tuple{MINDFul.IBNFramework, MINDFul.IntentDAGNode{<:MINDFul.ConnectivityIntent}, F, MINDFul.SplitGlobalNode, Dict{MINDFul.ConnectivityIntent, Symbol}}} where F<:Function","page":"API","title":"MINDFul.splitandcompilecrossdomainconnectivityintent","text":"splitandcompilecrossdomainconnectivityintent(\n    ibnf::MINDFul.IBNFramework,\n    idagnode::MINDFul.IntentDAGNode{<:MINDFul.ConnectivityIntent},\n    intradomainalgfun::Function,\n    splitbordernode::MINDFul.SplitGlobalNode,\n    cachedintentresult::Dict{MINDFul.ConnectivityIntent, Symbol};\n    verbose,\n    offsettime\n) -> Symbol\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.splitandcompileintradomainconnecivityintent!-Union{Tuple{F4}, Tuple{F3}, Tuple{F2}, Tuple{F}, Tuple{MINDFul.IBNFramework, MINDFul.IntentDAGNode{<:MINDFul.ConnectivityIntent}, F, MINDFul.SplitGlobalNode, Dict{MINDFul.ConnectivityIntent, Symbol}}} where {F<:Function, F2<:Function, F3<:Function, F4<:Function}","page":"API","title":"MINDFul.splitandcompileintradomainconnecivityintent!","text":"splitandcompileintradomainconnecivityintent!(\n    ibnf::MINDFul.IBNFramework,\n    idagnode::MINDFul.IntentDAGNode{<:MINDFul.ConnectivityIntent},\n    intradomainalgfun::Function,\n    splitglobalnode::MINDFul.SplitGlobalNode,\n    cachedintentresult::Dict{MINDFul.ConnectivityIntent, Symbol};\n    verbose,\n    prioritizegrooming,\n    prioritizesplitnodes,\n    prioritizesplitbordernodes,\n    offsettime\n)\n\n\nSplits connectivity intent on splitglobalnode with O-E-O conversion\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.stage!-Tuple{MINDFul.ReservableResourceView, MINDFul.LowLevelIntent}","page":"API","title":"MINDFul.stage!","text":"stage!(\n    resourceview::MINDFul.ReservableResourceView,\n    lli::MINDFul.LowLevelIntent;\n    verbose\n) -> Symbol\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.stageaddidagnode!-Tuple{MINDFul.IBNFramework, MINDFul.LowLevelIntent}","page":"API","title":"MINDFul.stageaddidagnode!","text":"stageaddidagnode!(\n    ibnf::MINDFul.IBNFramework,\n    lli::MINDFul.LowLevelIntent;\n    parentid,\n    intentissuer,\n    offsettime\n) -> Union{Nothing, Symbol}\n\n\nStage lli as compiled in the equipment and add LLI in the intent DAG. Staged LLIs are not reserved but used to know that they will be in the future.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.stageunstageleafintent!-Tuple{MINDFul.IBNFramework, MINDFul.LowLevelIntent, Bool}","page":"API","title":"MINDFul.stageunstageleafintent!","text":"stageunstageleafintent!(\n    ibnf::MINDFul.IBNFramework,\n    lli::MINDFul.LowLevelIntent,\n    dostage::Bool;\n    about2install\n) -> Union{Nothing, Symbol}\n\n\ndostage true for stage, false for unstage about2install = true only when dostage=false for unstaging when groing to installed state. This is only used to not deallocate the spectrum.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.startibnserver!-Tuple{Dict{Int64, MINDFul.IBNFramework}, Bool, Vector{String}, Int64}","page":"API","title":"MINDFul.startibnserver!","text":"startibnserver!(\n    ibnfsdict::Dict{Int64, MINDFul.IBNFramework},\n    encryption::Bool,\n    neighbourips::Vector{String},\n    port::Int64;\n    verbose\n) -> HTTP.Servers.Server\n\n\nFunction to start the HTTP server of an IBNFramework.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.unreserve!-Tuple{MINDFul.AbstractSDNController, MINDFul.ReservableResourceView, Base.UUID}","page":"API","title":"MINDFul.unreserve!","text":"unreserve!(\n    sdn::MINDFul.AbstractSDNController,\n    resourceview::MINDFul.ReservableResourceView,\n    dagnodeid::Base.UUID;\n    verbose\n) -> Symbol\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.unstage!-Tuple{MINDFul.ReservableResourceView, MINDFul.LowLevelIntent}","page":"API","title":"MINDFul.unstage!","text":"unstage!(\n    resourceview::MINDFul.ReservableResourceView,\n    lli::MINDFul.LowLevelIntent;\n    verbose,\n    about2install\n) -> Symbol\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.updateidagnodestates!","page":"API","title":"MINDFul.updateidagnodestates!","text":"updateidagnodestates!(\n    ibnf::MINDFul.IBNFramework,\n    idagnode::MINDFul.IntentDAGNode;\n    ...\n) -> Bool\nupdateidagnodestates!(\n    ibnf::MINDFul.IBNFramework,\n    idagnode::MINDFul.IntentDAGNode,\n    makestate::Union{Nothing, MINDFul.IntentState.T};\n    offsettime\n) -> Bool\n\n\nReturn value is true if state is changed.\n\n\n\n\n\n","category":"function"},{"location":"API/#MINDFul.updatelogintentcomp!-Tuple{MINDFul.IBNFramework{A, B, C, D, R} where {A, B, C, D, R<:MINDFul.IntentCompilationAlgorithmWithMemory}}","page":"API","title":"MINDFul.updatelogintentcomp!","text":"updatelogintentcomp!(\n    ibnf::MINDFul.IBNFramework{A, B, C, D, R} where {A, B, C, D, R<:MINDFul.IntentCompilationAlgorithmWithMemory};\n    offsettime\n)\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.updatelogintentcomp!-Union{Tuple{MINDFul.IBNFramework{A, B, C, D, E}}, Tuple{E}, Tuple{D}, Tuple{C}, Tuple{B}, Tuple{A}} where {A, B, C, D, E}","page":"API","title":"MINDFul.updatelogintentcomp!","text":"updatelogintentcomp!(\n    ibnf::MINDFul.IBNFramework{A, B, C, D, E};\n    offsettime\n)\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.@logtime-Tuple{}","page":"API","title":"MINDFul.@logtime","text":"This macro is used to calculate the current (simulated) time as offsettime + (now() - entrytime)\n\n\n\n\n\n","category":"macro"},{"location":"API/#MINDFul.@passtime-Tuple{}","page":"API","title":"MINDFul.@passtime","text":"This macro is used to pass the (simulated) timing information. It basically passes (; offsettime)\n\nThis strategy calls now() every time before passing the arguments. If that proves to slow down the implementation consider to pass offsettime, entrytime around and calcualte @logtime once in the end. Another caveat is that the communication overhead between domains is not measured. An offsetime=nothing logs the time of the current system.\n\n\n\n\n\n","category":"macro"},{"location":"API/#MINDFul.@recvtime-Tuple{Any}","page":"API","title":"MINDFul.@recvtime","text":"This macro is used to receive the (simulated) timing information. This macro does two things:\n\nputs the offsettime::DateTime=now() in the input keyword parameters\nputs entrytime = now() as the first command to happen in the function\n\nUse @logtime to calculate the current time inside the function. Use @passtime to pass the timing information to another function.\n\n\n\n\n\n","category":"macro"},{"location":"API/#MINDFul.@returnfalseiffalse-Tuple{Any, Any}","page":"API","title":"MINDFul.@returnfalseiffalse","text":"Return a return false if the expression ex evaluates to false. If verbose=true print the statement and the location. If the expression passed is true do nothing.\n\n\n\n\n\n","category":"macro"},{"location":"API/#MINDFul.@returniffalse-Tuple{Any, Any}","page":"API","title":"MINDFul.@returniffalse","text":"Return a return ReturnCodes.Fail if the expression ex evaluates to false. If verbose=true print the statement and the location. If the expression passed is true do nothing. TODO: have also a helper message be printed\n\n\n\n\n\n","category":"macro"},{"location":"API/#MINDFul.@returnwtimeiffalse-Tuple{Any, Any}","page":"API","title":"MINDFul.@returnwtimeiffalse","text":"Return a return ReturnCodeTime(ReturnCodes.Fail, @logtime) if the expression ex evaluates to false. That need to happen inside a @recvtime function If verbose=true print the statement and the location. If the expression passed is true do nothing. TODO: have also a helper message be printed\n\n\n\n\n\n","category":"macro"}]
}
